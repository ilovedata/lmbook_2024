<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>통계적 예측모형 - 5&nbsp; 관측값에 대한 진단</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../references.html" rel="next">
<link href="../qmd/modeleval2.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script type="text/javascript">
 window.MathJax = {
  tex: {
    macros: {
    RR: '{\\mathbb R}',                    // a simple string replacement
    hatmat:'{\\pmb X ({\\pmb X}^t {\\pmb X} )^{-1} {\\pmb X}^t}',
    bold: ['\\boldsymbol{#1}',1] ,     // this macro has one parameter
    pardiff: ['\\frac{\\partial#2}{\\partial#1}', 2, 'x'], // this macro has an optional parameter that defaults to 'x'
    pardifftwo: ['\\frac{\\partial#1}{\\partial#2}', 2],
    pardiffd: ['\\frac{\\partial#1}{\\partial#2^t \\partial#2}', 2],
    pardiffdd: ['\\frac{\\partial#1}{\\partial#3 \\partial#2}', 3],
    norm: ['\\lVert#1\\rVert',1]
  },
  environments: {
  braced: ["\\left\\{", "\\right\\}"]
  }
 }
};
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../qmd/residual.html"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">관측값에 대한 진단</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">통계적 예측모형</a> 
        <div class="sidebar-tools-main">
    <a href="../통계적-예측모형.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="검색"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/lse.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">선형 회귀모형의 소개</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/inference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">선형회귀에서의 추론</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/inference2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">모형의 비교</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/modeleval2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">모형의 진단</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/residual.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">관측값에 대한 진단</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_mat_basic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">행렬의 기초</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_vector_space.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">벡터공간</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_eigen_value.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">고유값과 고유벡터</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_vec_cal.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">벡터 미분</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/multivar.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">다변량 확률변수의 성질</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/quadratic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">이차형식과 제곱합의 분포</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">G</span>&nbsp; <span class="chapter-title">중회귀 모형 적합</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">H</span>&nbsp; <span class="chapter-title">중회귀 모형 진단</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul class="collapse">
  <li><a href="#서론" id="toc-서론" class="nav-link active" data-scroll-target="#서론"><span class="header-section-number">5.1</span> 서론</a></li>
  <li><a href="#이상점의-유형" id="toc-이상점의-유형" class="nav-link" data-scroll-target="#이상점의-유형"><span class="header-section-number">5.2</span> 이상점의 유형</a></li>
  <li><a href="#지렛값" id="toc-지렛값" class="nav-link" data-scroll-target="#지렛값"><span class="header-section-number">5.3</span> 지렛값</a></li>
  <li><a href="#내-표준화-잔차" id="toc-내-표준화-잔차" class="nav-link" data-scroll-target="#내-표준화-잔차"><span class="header-section-number">5.4</span> 내 표준화 잔차</a></li>
  <li><a href="#관측값의-영향-계수-추정" id="toc-관측값의-영향-계수-추정" class="nav-link" data-scroll-target="#관측값의-영향-계수-추정"><span class="header-section-number">5.5</span> 관측값의 영향: 계수 추정</a></li>
  <li><a href="#외-표준화-잔차와-press-잔차" id="toc-외-표준화-잔차와-press-잔차" class="nav-link" data-scroll-target="#외-표준화-잔차와-press-잔차"><span class="header-section-number">5.6</span> 외 표준화 잔차와 PRESS 잔차</a></li>
  <li><a href="#관측값의-영향-분산-추정" id="toc-관측값의-영향-분산-추정" class="nav-link" data-scroll-target="#관측값의-영향-분산-추정"><span class="header-section-number">5.7</span> 관측값의 영향: 분산 추정</a></li>
  <li><a href="#영향력의-측도" id="toc-영향력의-측도" class="nav-link" data-scroll-target="#영향력의-측도"><span class="header-section-number">5.8</span> 영향력의 측도</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-residual" class="quarto-section-identifier"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">관측값에 대한 진단</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="서론" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="서론"><span class="header-section-number">5.1</span> 서론</h2>
<p>회귀분석을 포함한 통계적 자료분석에서 흔하게 접하는 문제는 자료 중의 일부가 통계적 모형에 의해 추정된 평균적인 경향에서 매우 벗어나 있는 점을 발견하게 되는 경우이다.</p>
<p>이러한 경우 평균적인 경향에서 매우 벗어난 자료를 분석에서 제외시킬 것인지에 대한 논의도 필요할 수 있으며 이러한 자료들이 모형의 모수에 대한 추정에 어떤 영향을 미칠 것인자에 대한 검토도 필요할 수 있다.</p>
<p>평균적인 경향에서 매우 벗어난 자료를 흔히 이상점(outlier)라고 부른다. 회귀분석에서 이러한 이상점은 회귀계수 추정과 그에 따른 여러 가지 통계적 추론에 많은 영향을 미친다. 따라서 이상점들이 회귀분석의 계수 추정에 어떤 영향을 얼만큼 끼치는가에 대한 검토는 매우 중요하다.</p>
</section>
<section id="이상점의-유형" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="이상점의-유형"><span class="header-section-number">5.2</span> 이상점의 유형</h2>
<p>일차원 자료에서는 평균적인 경향에서 매우 벗어난 자료의 식별이 단순하고 쉽다. 예를 들어 다음과 같이 일변량 자료 <span class="math inline">\(\pmb x\)</span>만 고려하면 이상점이 어떤 점인지는 쉽게 찾을 수 있다.</p>
<p><span class="math display">\[ \pmb x^t = (1,2,3,4,5,10) \]</span></p>
<p>그러나 반응변수와 독립변수들을 고려해야 하는 회귀분석에서 이상점은 간단하게 파악하기 힘들고 상황에 따라 그 의미가 매우 다르다.</p>
<p>회귀분석에서 이상점의 다양한 종류와 그 영향을 알아보기 위하여 단순회귀분석을 고려하고 다음 그림을 보자.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../myimages/outliers.png" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>여러가지 종류의 이상점과 그 영향</figcaption>
</figure>
</div>
</div>
</div>
<p>위의 그림에서 실선은 검정색 점을 포함해서 적합한 회귀직선이고 점선은 검정색 점을 제외했을 때의 회귀직선이다</p>
<p>그림의 (a)에서 검정색 점은 설명변수 <span class="math inline">\(x\)</span>에 대해서는 이상점이 아니지만 <span class="math inline">\(x\)</span>가 주어진 경우 반응변수 <span class="math inline">\(y\)</span>에 대해서는 평균적인 경향에서 많이 벗어나 있기 때문에 이상점이다. 이러한 이상점을 회귀이상점(regression outlier)라고 부르기도 한다. (a)의 회귀이상점의 유무는 회귀계수의 추정에 크게 영향을 주지 않는다. 이렇게 어떤 관측점이 있고 없음에 따라 회귀계수의 값이 크게 변하지 않는다면 그 자료의 영향력(leverage)이 작다고 한다.</p>
<p>(b)에서의 검은 점은 설명변수 <span class="math inline">\(x\)</span>에 대하여 이상점이며 또한 회귀이상점이다. 더 나아가 이 이상점을 제외하고 적합한 회귀계수는 이상점을 포함했을 때 적합한 회귀계수와 매우 다르다. 이 경우 이 이상점은 큰 영향력을 가졌다고 말한다.</p>
<p>(c)에서의 검은 점은 설명변수 <span class="math inline">\(x\)</span>에 대해서 이상점이지만 회귀이상점은 아니다. 이러한 경우 이상점의 유무에 따라 회귀계수의 값이 크게 변하지 않으므로 이상점은 작은 영향력을 가졌다고 말한다. 하지만 (c)에서의 검은 점이 설명변수 <span class="math inline">\(x\)</span>의 중심점으로부터 크게 멀어져있으므로 <span class="math inline">\(y\)</span>의 값이 조그만 변해도 그림 (d)와 같이 큰 영향력을 가진다.</p>
<p>관측치 <span class="math inline">\(y_i\)</span> 를 제외할 때와 포함할 때의 회귀계수 추정치가 매우 다르면 그 관측치를 영향점(influential point)라고 하며 그 영향의 크기는 그 점이 가진 영향력(leverage)의 크기와 평균에서 떨어진 정도에 비례한다.</p>
<div class=".callout-note">
<p>자료가 선형모형의 계수 추정에 미치는 영향 <span class="math inline">\(\propto\)</span> 영향력의 크기 <span class="math inline">\(\times\)</span> 이상치의 특이한 정도</p>
</div>
<p>위에서 살펴보았듯이 회귀분석에서 이상점의 종류와 그 영향은 매우 다양하며 복잡하다. 이러한 이상점의 종류와 회귀계수의 영향에 대하여 분석할 때 유용하게 쓰이는 통계량이 잔차(residual)이다.</p>
</section>
<section id="지렛값" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="지렛값"><span class="header-section-number">5.3</span> 지렛값</h2>
<p><span class="math inline">\(y\)</span>가 반응변수이고 <span class="math inline">\(p-1\)</span>개의 설명변수 <span class="math inline">\(x_1,x_2,\dots,x_{p-1}\)</span>가 있을 때 회귀식은 다음과 같이 표현된다.</p>
<p><span class="math display">\[ \pmb y = \pmb X \pmb \beta + \pmb e \]</span></p>
<p>회귀계수 <span class="math inline">\(\pmb \beta\)</span>의 최소제곱 추정치 <span class="math inline">\(\hat{ \pmb \beta}\)</span>는 다음과 같이 주어지며</p>
<p><span class="math display">\[ \hat{ \pmb \beta} = (\pmb X^t \pmb X)^{-1} \pmb X^t \pmb y \]</span></p>
<p>관측값 <span class="math inline">\(\pmb y\)</span> 의 추정치 <span class="math inline">\(\hat {\pmb y}\)</span>는 다음과 같다.</p>
<p><span class="math display">\[  \hat {\pmb y} = \pmb X \hat{ \pmb \beta} =  \pmb X (\pmb X^t \pmb X)^{-1} \pmb X^t \pmb y \equiv \pmb H \pmb y \]</span></p>
<p>여기서 <span class="math inline">\(\pmb H= \pmb X (\pmb X^t \pmb X)^{-1} \pmb X^t\)</span>를 사영행렬(hat matrix 또는 projection matrix)라고 부르며 사영행렬 <span class="math inline">\(\pmb H\)</span> 의 <span class="math inline">\(i\)</span> 번째 대각원소를 <span class="math inline">\(h_{ii}\)</span>라고 하며 이는 이상치 또는 영향치 분석에 중요한 역할을 한다.</p>
<p><span class="math inline">\(i\)</span>번째 관측치의 설명변수 벡터를 다음과 같이 표시하면</p>
<p><span class="math display">\[\pmb x_{i}^t=(1, x_{i1},x_{i2},\dots, x_{i,p-1}) \]</span></p>
<p><span class="math inline">\(\pmb H\)</span> 의 <span class="math inline">\(i\)</span> 번째 대각원소를 <span class="math inline">\(h_{ii}\)</span>는 다음과 같이 표현된다.</p>
<p><span id="eq-hii"><span class="math display">\[
h_{ii} = \pmb x_{i}^t (\pmb X^t \pmb X)^{-1}  \pmb x_{i}
\tag{5.1}\]</span></span></p>
<p><span class="math inline">\(h_{ii}\)</span>는 <span class="math inline">\(i\)</span> 번째 관측치의 설명변수 <span class="math inline">\((x_{i1},x_{i2},\dots, x_{i,p-1})\)</span> 들이 모든 관측치의 평균 <span class="math inline">\((\bar x_1, \bar x_2,\dots, \bar x_{p-1})\)</span> 에서 얼마나 멀리 떨어져 있는가에 대한 상대적인 양을 나타낸다. 따라서 <span class="math inline">\(h_{ii}\)</span> 를 지렛점(leverage point)라고 부른다.</p>
<p>지렛점 값이 클수로 영향점일 가능성이 크며 큰 값을 높은 지렛값(high leverage point)라고 부른다.</p>
<p>보통 <span class="math inline">\(h_{ii}\)</span>값이 <span class="math inline">\(p/n\)</span>보다 크면 영향력이 크다고 말한다. 참고로 단순 회귀식에서 <span class="math inline">\(h_{ii}\)</span>는 다음과 같이 주어진다.</p>
<p><span class="math display">\[ h_{ii} = \frac{1}{n} + \frac{ ( x_i-\bar x)^2 }{\sum (x_i-\bar x)^2} \]</span></p>
<p>또한 <span class="math inline">\(h_{ii}\)</span>값을 모두 더하면 설명변수의 개수와 같다. <span class="math display">\[ tr(\pmb H)=\sum_{i=1}^k h_{ii} = p \]</span></p>
</section>
<section id="내-표준화-잔차" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="내-표준화-잔차"><span class="header-section-number">5.4</span> 내 표준화 잔차</h2>
<p>잔차 <span class="math inline">\(r_i\)</span>는 <span class="math inline">\(y\)</span> 의 실제 관측값과 그 추정치의 차이이며</p>
<p><span id="eq-resid"><span class="math display">\[
r_i = y_i -\hat y_i  = y_i - {\pmb x}_i^t \hat {\pmb \beta}
\tag{5.2}\]</span></span></p>
<p>잔차벡터에 대한 식은 다음과 같다.</p>
<p><span id="eq-residvec"><span class="math display">\[
\pmb r = \pmb y - \hat {\pmb y} = \pmb y - \pmb H \pmb y = (\pmb I-\pmb H)\pmb y
\tag{5.3}\]</span></span></p>
<p>잔차의 공분산 행렬을 살펴보면 다음과 같이 주어진다. 따라서 <span class="math inline">\(i\)</span> 번째 잔차의 분산은 <span class="math inline">\(Var(r_i) = (1-h_{ii})\sigma^2\)</span> 이다.</p>
<p><span id="eq-residvar"><span class="math display">\[
Var(\pmb r) = \sigma^2 (\pmb I-\pmb H)
\tag{5.4}\]</span></span></p>
<p>위에서 언급한 잔차 <span class="math inline">\(r_i\)</span> 를 보통 잔차(ordinary residual)이라고 하며 그 크기가 단위에 따라 바뀌므로 잔차분석에서는 표준화 잔차(standardized residual)을 더 많이 사용한다.</p>
<p>아래와 같이 잔차를 그 표준편차로 나눈 값을 <strong>내 표준화 잔차(internally studentized residual)</strong> 이라고 부른다.</p>
<p><span id="eq-residinternal"><span class="math display">\[
r^s_i = \frac{r_i}{s \sqrt{1-h_{ii}}}
\tag{5.5}\]</span></span></p>
<p>위의 식에서 <span class="math inline">\(s\)</span>는 오차항의 표준편차 <span class="math inline">\(\sigma\)</span>의 추정량이며 <span class="math inline">\(h_{ii}\)</span>는 사영행렬 <span class="math inline">\(\pmb H\)</span> 의 <span class="math inline">\(i\)</span> 번째 대각원소(즉 지렛값)이다.</p>
<p>잔차분석에서는 척도(scale)에 영향이 없는 표준화 잔차를 이용하는 것이 좋다. 그 값이 클수로 이상치일 가능성이 크다. 보통 내표준화 잔차의 절대값이 2보다 크면 이상치일 가능성이 크다.</p>
</section>
<section id="관측값의-영향-계수-추정" class="level2" data-number="5.5">
<h2 data-number="5.5" class="anchored" data-anchor-id="관측값의-영향-계수-추정"><span class="header-section-number">5.5</span> 관측값의 영향: 계수 추정</h2>
<p>회귀분석에서 하나의 관측치가 회귀계수의 추정에 영향을 미치는 정도를 알아볼 때 유용한 방법은 그 관측치를 제외했을 때의 최소제곱추정량과 포함했을 때의 추정량을 비교하는 것이다.</p>
<p><span class="math inline">\(i\)</span>번째 관측치에 대한 반응값과 설명변수들이 다음과 같은 때</p>
<p><span class="math display">\[ y_i, \quad \pmb x_{i}^t=(1, x_{i1},x_{i2},\dots, x_{i,p-1}) \]</span></p>
<p><span class="math inline">\(i\)</span>번째 관측치를 제외한 자료에서 반응변수와 설명변수의 벡터식을 다음과 같이 표시한다.</p>
<p><span class="math display">\[ \pmb y_{-i}, \quad \pmb X_{-i} \]</span></p>
<p><span class="math inline">\(i\)</span>번째 관측치를 제외했을 때 회귀계수의 최소제곱추정량을 <span class="math inline">\(\hat{ \pmb \beta}_{-i}\)</span>라 하면 모든 관측치를 이용한 최소제곱추정량을 <span class="math inline">\(\hat{ \pmb \beta}\)</span>와의 관계는 다음과 같이 나타낼 수 있다. 아래 식 세번째 중의 결과는 우드베리 공식 <a href="math_mat_basic.html#eq-woodbury" class="quarto-xref">식&nbsp;<span>A.3</span></a> 을 이용하였다.</p>
<p><span id="eq-betaminusi"><span class="math display">\[
\begin{aligned}
\hat{ \pmb \beta}_{-i} &amp; =  (\pmb X_{-i}^t \pmb X_{-i})^{-1} \pmb X_{-i}^t \pmb y_{-i}\\
&amp; = (\pmb X^t \pmb X - \pmb x_{i} \pmb x_{i}^t)^{-1} (\pmb X^t \pmb y -  \pmb x_{i} y_{i}) \\
&amp; = \left [ (\pmb X^t \pmb X)^{-1} - \frac { (\pmb X^t \pmb X)^{-1}  \pmb x_{i} \pmb x_{i}^t
  (\pmb X^t \pmb X)^{-1}  }{ 1- \pmb x_{i}^t (\pmb X^t \pmb X)^{-1}  \pmb x_{i} } \right ]
(\pmb X^t \pmb y -  \pmb x_{i} y_{i})  \\
&amp; = \hat{ \pmb \beta} + \frac{1}{1-h_{ii}} (\pmb X^t \pmb X)^{-1}  \pmb x_i \left [ \pmb x_i^t \hat{ \pmb \beta} - (1-h_{ii}) y_i - h_{ii} y_i \right ] \\
&amp; =  \hat{ \pmb \beta} - \frac{1}{1-h_{ii}} (\pmb X^t \pmb X)^{-1}  \pmb x_i ( y_i - \pmb x_i^t \hat{ \pmb \beta}) \\
&amp; =  \hat{ \pmb \beta} - \frac{r_i}{1-h_{ii}} (\pmb X^t \pmb X)^{-1}  \pmb x_i
\end{aligned}
\tag{5.6}\]</span></span></p>
<p>또한 <span class="math inline">\(i\)</span>번째 관측치를 제외했을 때 오차항 분산의 추정량을 <span class="math inline">\(s^2_{-i}\)</span>로 나타낸다.</p>
<p><span id="eq-s2minusi"><span class="math display">\[
s^2_{-i} = \frac{1}{n-p-1} \sum_{j \ne i} (y_j - {\pmb x}_j^t \hat{ \pmb \beta}_{-i} )^2
\tag{5.7}\]</span></span></p>
</section>
<section id="외-표준화-잔차와-press-잔차" class="level2" data-number="5.6">
<h2 data-number="5.6" class="anchored" data-anchor-id="외-표준화-잔차와-press-잔차"><span class="header-section-number">5.6</span> 외 표준화 잔차와 PRESS 잔차</h2>
<p>잔차를 표준화 할 떄 <span class="math inline">\(i\)</span>번째 관측치를 제외했을 때 분산의 추정량을 <span class="math inline">\(s^2_{-i}\)</span>을 이용하는 것이 합리적이다. 이는 반응값이 이상점인 경우 분산의 추정량이 커지게 된다. 식 <a href="#eq-residinternal" class="quarto-xref">식&nbsp;<span>5.5</span></a> 에서 정의된 내 표준화 잔차에서는 이상점이 분산의 추정량에 영향을 주어 잔차의 크기가 작아지게 된다. 따라서 내 표본화 잔차는 이상점을 구별할 수 있는 능력이 떨어진다. 이러한 점을 보완하기 위하여 이상점의 영향을 약화시킬 수 있도록 <span class="math inline">\(s^2_{-i}\)</span>를 이용하여 표준화 한 양이 아래와 같이 정의된 표준화 잔차이다.</p>
<p><span id="eq-residexternal"><span class="math display">\[
r^*_i = \frac{r_i}{s_{-i} \sqrt{1-h_{ii}}}
\tag{5.8}\]</span></span></p>
<p>식 <a href="#eq-residexternal" class="quarto-xref">식&nbsp;<span>5.8</span></a> 에서 정의된 차를 표준화 잔차(studentized residual) 또는 <strong>외 표준화 잔차(externally studentized residual)</strong>라고 부른다.</p>
<p>외 표준화 잔차는 <span class="math inline">\(i\)</span>번째 관측치가 회귀식 적합에 미치는 영향을 내 표분화 잔차보다 더 민감하게 탐색할 수 있다. 보통 외 표준화 잔차의 절대값이 2보다 크면 이상치일 가능성이 크다.</p>
<p><strong>PRESS 잔차</strong> <span class="math inline">\(r_{i,-i}\)</span>는 <span class="math inline">\(i\)</span> 번쨰 관측값을 빼고 적합한 회귀식으로 부터 얻은 <span class="math inline">\(E(y| \pmb x_i)\)</span>의 추정치 <span class="math inline">\(\hat y_{i,-i}\)</span>를 이용하여 만든 잔차이다. PRESS 잔차는 다음과 같이 정의된다.</p>
<p><span id="eq-residpress"><span class="math display">\[
r_{i,-i}  =   y_i - \hat y_{i,-i} = y_i - \pmb x^t_i \hat{ \pmb \beta}_{-i}
\tag{5.9}\]</span></span></p>
<p>실제 PRESS 잔차를 구할 경우 관측값을 제외하지 않고도 원래의 회귀식을 이용하여 아래와 같이 쉽게 구할 수 있다. 그 값이 클수로 이상치 또는 영향점일 가능성이 크다.</p>
<p><span id="eq-pressrelation"><span class="math display">\[
\begin{aligned}
r_{i,-i} &amp; =   y_i - \hat y_{i,-i} \\
&amp; =y_i - \pmb x^t_i \hat{ \pmb \beta}_{-i}  \\
&amp; = y_i - \pmb x^t_i  \left [ \hat{ \pmb \beta} - \frac{1}{1-h_{ii}} (\pmb X^t \pmb X)^{-1}  \pmb x_i r_i \right ] \\
&amp;= (y_i - \pmb x^t_i \hat{ \pmb \beta}) +   r_i  \frac{\pmb x^t_i (\pmb X^t \pmb X)^{-1}  \pmb x_i}{1-h_{ii}} \\
&amp;= \frac{r_i}{1-h_{ii}}
\end{aligned}
\tag{5.10}\]</span></span></p>
</section>
<section id="관측값의-영향-분산-추정" class="level2" data-number="5.7">
<h2 data-number="5.7" class="anchored" data-anchor-id="관측값의-영향-분산-추정"><span class="header-section-number">5.7</span> 관측값의 영향: 분산 추정</h2>
<p>참고로 식 <a href="#eq-s2minusi" class="quarto-xref">식&nbsp;<span>5.7</span></a> 에서 정의된 <span class="math inline">\(s^2_{-i}\)</span> 과 <span class="math inline">\(s^2 = SSE/(n-p)\)</span>의 관계를 살펴보자. 먼저 <span class="math inline">\(SSE\)</span>의 정의와 식 <a href="#eq-betaminusi" class="quarto-xref">식&nbsp;<span>5.6</span></a> 과 <a href="#eq-pressrelation" class="quarto-xref">식&nbsp;<span>5.10</span></a> 를 이용하여 다음과 같은 분해가 가능하다.</p>
<p><span class="math display">\[
\pmb y - {\pmb X} \hat{ \pmb \beta}_{-i}  = ( \pmb y - {\pmb X} \hat{ \pmb \beta}) +
\frac{r_i}{1-h_{ii}} \pmb X (\pmb X^t \pmb X)^{-1}  \pmb x_i
\]</span></p>
<p>따라서</p>
<p><span id="eq-sseminusi"><span class="math display">\[
\begin{aligned}
&amp; \sum_{j \ne i} (y_j - {\pmb x}_j^t \hat{ \pmb \beta}_{-i} )^2   + (y_i - \hat {y}_{i,-i} )^2 \\
&amp; = \sum_{j \ne i} (y_j - {\pmb x}_j^t \hat{ \pmb \beta}_{-i} )^2   + (y_i - {\pmb x}_i^t \hat{ \pmb \beta}_{-i} )^2  \\
  &amp; = ( \pmb y - \pmb X \hat {\pmb \beta}_{-i})^t ( \pmb y - \pmb X \hat {\pmb \beta}_{-i}) \\
  &amp; = ( \pmb y - \pmb X \hat {\pmb \beta})^t ( \pmb y - \pmb X \hat {\pmb \beta})
   -2 \frac{r_i}{1-h_{ii}} ( \pmb y - \pmb X \hat {\pmb \beta})^t  \pmb X (\pmb X^t \pmb X)^{-1}  \pmb x_i  \\
   &amp; \quad + \frac{r^2_i}{(1-h_{ii})^2} \pmb x_i^t  (\pmb X^t \pmb X)^{-1} \pmb X^t \pmb X (\pmb X^t \pmb X)^{-1}  \pmb x_i  \\
   &amp; = ( \pmb y - \pmb X \hat {\pmb \beta})^t ( \pmb y - \pmb X \hat {\pmb \beta})
   -2 \frac{r_i}{1-h_{ii}}  \pmb y^t(\pmb I - \pmb H)  \pmb X (\pmb X^t \pmb X)^{-1}  \pmb x_i  \\
   &amp; \quad  + \frac{r^2_i}{(1-h_{ii})^2} \pmb x_i^t (\pmb X^t \pmb X)^{-1}  \pmb x_i  \\
    &amp; = SSE + 0 + \frac{r^2_i}{(1-h_{ii})^2} h_{ii}  \\
    &amp; = SSE  + \frac{r^2_i h_{ii}}{(1-h_{ii})^2}   
\end{aligned}
\tag{5.11}\]</span></span></p>
<p>이제 위의 식의 결과와 식 <a href="#eq-pressrelation" class="quarto-xref">식&nbsp;<span>5.10</span></a> 를 이용하면 다음과 같은 결과를 얻는다.</p>
<p><span id="eq-sseminusi2"><span class="math display">\[
\begin{aligned}
\sum_{j \ne i} (y_j - {\pmb x}_j^t \hat{ \pmb \beta}_{-i} )^2   
&amp; =  SSE  + \frac{r^2_i h_{ii}}{(1-h_{ii})^2}   -  (y_i - \hat {y}_{i,-i} )^2 \\
&amp; = SSE  + \frac{r^2_i h_{ii}}{(1-h_{ii})^2}   -  (y_i - \hat {y}_{i,-i} )^2 \\
  &amp; = SSE  + \frac{r^2_i h_{ii}}{(1-h_{ii})^2}   -   \frac{r^2_i}{(1-h_{ii})^2} \\
  &amp; = SSE  - \frac{r^2_i }{1-h_{ii}}    
\end{aligned}
\tag{5.12}\]</span></span></p>
<p>따라서 다음 식을 이용하면 <span class="math inline">\(s^2_{-i}\)</span>은 모든 관측값을 이용한 <span class="math inline">\(s^2\)</span>으로부터 쉽게 유도할 수 있다.</p>
<p><span id="eq-s2relation"><span class="math display">\[
(n-p-1) s^2_{-i} = (n-p)s^2 + - \frac{r^2_i }{1-h_{ii}}    
\tag{5.13}\]</span></span></p>
</section>
<section id="영향력의-측도" class="level2" data-number="5.8">
<h2 data-number="5.8" class="anchored" data-anchor-id="영향력의-측도"><span class="header-section-number">5.8</span> 영향력의 측도</h2>
<p>하나의 관측값이 있는 경우 회귀계수 추정치와 없는 경우의 추정치의 차이가 크면 그 관측값이 큰 영향력을 가진다. 이러한 영향력을 측정할 수 있는 측조에 대하여 알아보자.</p>
<p><strong>쿡의 거리(COOK’s distance)</strong> <span class="math inline">\(C_i\)</span>는 <span class="math inline">\(i\)</span>번째 관측치가 회귀식 적합의 계수에 미치는 영향을 나타내는 양으로서 다음과 같이 정의된다.</p>
<p><span id="eq-cookdist"><span class="math display">\[
C_i = \frac{  (\hat{ \pmb \beta} -\hat{ \pmb \beta}_{-i})^t [ \widehat {Cov}(\hat {\pmb \beta}]^{-1}
(\hat{ \pmb \beta} -\hat{ \pmb \beta}_{-i}) } {p} = \frac{  (\hat{ \pmb \beta} -\hat{ \pmb \beta}_{-i})^t (\pmb X^t \pmb X) (\hat{ \pmb \beta} -\hat{ \pmb \beta}_{-i}) } {p s^2}
\tag{5.14}\]</span></span></p>
<p>여기서 <span class="math inline">\(\hat{ \pmb \beta}_{-i}\)</span>는 <span class="math inline">\(i\)</span>번째 관측치를 제외하고 적합한 회귀식에 의한 회귀계수이며 <span class="math inline">\(p\)</span>는 설명변수의 개수이다. 그 값이 클수로 영향점일 가능성이 크다.</p>
<p>쿡의 거리 <span class="math inline">\(C_i\)</span>과 내 표준화 잔차와의 관계는 다음과 같다.</p>
<p><span class="math display">\[ C_i = \frac{ (r^s_i)^2}{p} \left ( \frac{h_{ii} }{1-h_{ii}} \right ) \]</span></p>
<p><strong>DFFITS</strong>는 <span class="math inline">\(n\)</span>개의 모든 자료를 이용했을 때의 <span class="math inline">\(i\)</span> 번째 관측값의 평균 <span class="math inline">\(E(y|\pmb x_i)\)</span>의 추정치 <span class="math inline">\(\hat y_i\)</span>와 <span class="math inline">\(i\)</span> 번쨰 관측값을 빼고 적합한 회귀식에 의한 추정치 <span class="math inline">\(\hat y_{i,-i}\)</span>의 표준화된 차이을 말한다.</p>
<p>즉, <span class="math inline">\(\hat y_{i,-i}\)</span>를 <span class="math inline">\(i\)</span>번째 관측치를 제외하고 적합한 회귀식에 의한 예측치라고 한다면 두 예측치의 차이 <span class="math inline">\(\hat y_i - \hat y_{i,-i}\)</span>를 표준화시키면 다음과 같다.</p>
<p><span id="eq-dffits"><span class="math display">\[
DFFITS_i = \frac{\hat y_i - \hat y_{i,-i}}{s_{-i}\sqrt{h_{ii}}}  
\tag{5.15}\]</span></span></p>
<p>DFFITS 는 그 값이 클수로 영향점일 가능성이 크다.</p>
<p>여기서 식 <a href="#eq-betaminusi" class="quarto-xref">식&nbsp;<span>5.6</span></a> 를 이용하면 다음 식를 얻고</p>
<p><span class="math display">\[ {\pmb x}_i^t \hat{ \pmb \beta}_{-i} =\pmb x_i^t \hat{ \pmb \beta} -\frac{r_i h_{ii}}{1-h_{ii}}\]</span></p>
<p>DFFITS과 잔차와의 관계를 알 수 있다.</p>
<p><span class="math display">\[
\begin{aligned}
DFFITS_i &amp; = \frac{\hat y_i - \hat y_{i,-i}}{s_{-i}\sqrt{h_{ii}}}  \\
&amp; =  \frac{ [h_{ii}/(1-h_{ii})]r_i } {s_{-i}\sqrt{h_{ii}}} \\
&amp; =  \frac{ r_i } {s_{-i}\sqrt{1-h_{ii}}} [h_{ii}/(1-h_{ii})]^{1/2} \\
&amp;= r^*_i \left [\frac{h_{ii}}{1-h_{ii}} \right ]^{1/2}
\end{aligned}
\]</span></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../qmd/modeleval2.html" class="pagination-link" aria-label="모형의 진단">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">모형의 진단</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../references.html" class="pagination-link" aria-label="References">
        <span class="nav-page-text">References</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>