<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>통계적 예측모형 - 2&nbsp; 선형회귀에서의 추론</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../qmd/inference2.html" rel="next">
<link href="../qmd/lse.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script type="text/javascript">
 window.MathJax = {
  tex: {
    macros: {
    RR: '{\\mathbb R}',                    // a simple string replacement
    hatmat:'{\\pmb X ({\\pmb X}^t {\\pmb X} )^{-1} {\\pmb X}^t}',
    bold: ['\\boldsymbol{#1}',1] ,     // this macro has one parameter
    pardiff: ['\\frac{\\partial#2}{\\partial#1}', 2, 'x'], // this macro has an optional parameter that defaults to 'x'
    pardifftwo: ['\\frac{\\partial#1}{\\partial#2}', 2],
    pardiffd: ['\\frac{\\partial#1}{\\partial#2^t \\partial#2}', 2],
    pardiffdd: ['\\frac{\\partial#1}{\\partial#3 \\partial#2}', 3],
    norm: ['\\lVert#1\\rVert',1]
  },
  environments: {
  braced: ["\\left\\{", "\\right\\}"]
  }
 }
};
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../qmd/inference.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">선형회귀에서의 추론</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">통계적 예측모형</a> 
        <div class="sidebar-tools-main">
    <a href="../통계적-예측모형.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="검색"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/lse.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">선형 회귀모형의 소개</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/inference.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">선형회귀에서의 추론</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/inference2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">모형의 비교</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/modeleval2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">모형의 진단</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/residual.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">관측값에 대한 진단</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/modelselection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">모형의 선택</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/anova.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">분산분석 모형</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/ancova.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">공분산분석</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/compute.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">최소제곱 추정량의 계산</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_mat_basic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">행렬의 기초</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_vector_space.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">벡터공간</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_eigen_value.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">고유값과 고유벡터</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_matrix_decomp.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">행렬의 분해</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_vec_cal.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">벡터 미분</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/multivar.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">다변량 확률변수의 성질</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/quadratic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">G</span>&nbsp; <span class="chapter-title">이차형식과 제곱합의 분포</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/aic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">H</span>&nbsp; <span class="chapter-title">모형선택의 정보 기준</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">I</span>&nbsp; <span class="chapter-title">R-실습: 중회귀 모형 적합</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">J</span>&nbsp; <span class="chapter-title">R-실습: 중회귀 모형 진단</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">K</span>&nbsp; <span class="chapter-title">R-실습: 관측값에 대한 진단</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">L</span>&nbsp; <span class="chapter-title">R-실습: 모형의 선택</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-05.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">M</span>&nbsp; <span class="chapter-title">R-실습: 분산분석 모형</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul class="collapse">
  <li><a href="#제곱합의-분포" id="toc-제곱합의-분포" class="nav-link active" data-scroll-target="#제곱합의-분포"><span class="header-section-number">2.1</span> 제곱합의 분포</a></li>
  <li><a href="#모분산의-추정" id="toc-모분산의-추정" class="nav-link" data-scroll-target="#모분산의-추정"><span class="header-section-number">2.2</span> 모분산의 추정</a></li>
  <li><a href="#최소제곱-추정량의-성질" id="toc-최소제곱-추정량의-성질" class="nav-link" data-scroll-target="#최소제곱-추정량의-성질"><span class="header-section-number">2.3</span> 최소제곱 추정량의 성질</a></li>
  <li><a href="#모형의-적합도-검정과-분산분석" id="toc-모형의-적합도-검정과-분산분석" class="nav-link" data-scroll-target="#모형의-적합도-검정과-분산분석"><span class="header-section-number">2.4</span> 모형의 적합도 검정과 분산분석</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-inference" class="quarto-section-identifier"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">선형회귀에서의 추론</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="제곱합의-분포" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="제곱합의-분포"><span class="header-section-number">2.1</span> 제곱합의 분포</h2>
<p>앞 장의 중회귀 모형 <a href="lse.html#eq-multireg2" class="quarto-xref">식&nbsp;<span>1.10</span></a> 에서 관측값 벡터 <span class="math inline">\(\pmb y\)</span>가 다변량 정규분포 <span class="math inline">\(N(\pmb X \pmb \beta, \sigma^2 \pmb I)\)</span>를 따를 때 회귀계수의 추정량 <span class="math inline">\(\hat {\pmb \beta}=(\pmb X^t \pmb X)^{-1} \pmb X^t \pmb y\)</span> 은 다음과 같은 분포를 따르는 것을 보였다.</p>
<p><span class="math display">\[ \hat {\pmb \beta} \sim N(\pmb \beta, \sigma^2 (\pmb X^t  \pmb X)^{-1}) \]</span></p>
<p>반응변수의 추정값을 구하는 식에서 다음과 같은 모자행렬(hat matrix) <span class="math inline">\(\pmb H = \pmb X (\pmb X^t \pmb X)^{-1} \pmb X^t\)</span> 을 정의하자. 여기서 중요한 점은 모자행렬은 대칭인 멱등행렬 (<span class="math inline">\(\pmb H \pmb H =\pmb H\)</span>)이며 이는 모자행렬이 사영행렬임을 의미한다.</p>
<p><span id="eq-hatmatrix"><span class="math display">\[
\hat {\pmb y} = \pmb X \hat {\pmb \beta} = \pmb X (\pmb X^t \pmb X)^{-1} \pmb X^t \pmb y = \pmb H \pmb y
\tag{2.1}\]</span></span></p>
<section id="잔차제곱합의-분포" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="잔차제곱합의-분포"><span class="header-section-number">2.1.1</span> 잔차제곱합의 분포</h3>
<p>이제 제곱합들의 분포를 알아보기로 하자. 먼저 잔차제곱합 <span class="math inline">\(SSE\)</span>를 이차 형식으로 표시해보자.</p>
<p><span class="math display">\[
\begin{aligned}
SSE &amp; = \sum_{i=1}^n (y_i - \hat y_i) \\
   &amp; = (\pmb y - \pmb X \hat {\pmb \beta})^t (\pmb y - \pmb X \hat {\pmb \beta}) \\
   &amp; = (\pmb y - \pmb H \pmb y)^t (\pmb y - \pmb H \pmb y) \\
   &amp; = \pmb y^t (\pmb I - \pmb H)^t (\pmb I - \pmb H) \pmb y \\
   &amp; = \pmb y^t (\pmb I - \pmb H) (\pmb I - \pmb H) \pmb y \\
   &amp; = \pmb y^t (\pmb I - \pmb H) \pmb y \\
\end{aligned}
\]</span></p>
<p>위의 식에서 <span class="math inline">\(\pmb I - \pmb H\)</span>는 멱등행렬이고 다음이 성립한다.</p>
<p><span class="math display">\[
(\pmb I - \pmb H) \pmb X = \pmb X - \pmb X (\pmb X^t \pmb X)^{-1} \pmb X^t \pmb X = \pmb 0
\]</span></p>
<p>따라서</p>
<p><span class="math display">\[
\pmb \mu^t (\pmb I - \pmb H)  \pmb \mu = \pmb \beta^t \pmb X^t (\pmb I - \pmb H) \pmb X \beta =0
\]</span></p>
<p>이므로 비중심 모수는 0이다.</p>
<p>또한</p>
<p><span class="math display">\[
\begin{aligned}
r(\pmb I - \pmb H) &amp; = tr(\pmb I - \pmb H) \\
&amp; = tr(\pmb I_n) - tr \left [ \pmb X (\pmb X^t \pmb X)^{-1} \pmb X^t \right ] \\
&amp; = n-tr \left [ (\pmb X^t \pmb X)^{-1} \pmb X^t \pmb X \right ]
\\
&amp;= n-tr (\pmb I_p ) \\
&amp; = n-p
\end{aligned}
\]</span></p>
<p>이므로 부록의 정리에 의하여 <span class="math inline">\(SSE\)</span>는 다음과 같이 중심 카이제곱 분포를 따른다.</p>
<p><span id="eq-distsse"><span class="math display">\[
\frac{SSE}{\sigma^2} \sim \chi^2(n-p)
\tag{2.2}\]</span></span></p>
</section>
<section id="회귀제곱합의-분포" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="회귀제곱합의-분포"><span class="header-section-number">2.1.2</span> 회귀제곱합의 분포</h3>
<p>다음으로 회귀제곱합 <span class="math inline">\(SSR\)</span>의 분포를 유도해보자.</p>
<p><span class="math display">\[
\begin{aligned}
SSR &amp; = \sum_{i=1}^n (\hat y_i - \bar y) \\
   &amp; = (\pmb X \hat {\pmb \beta} - \bar y \pmb 1 )^t (\pmb X \hat {\pmb \beta} - \bar y \pmb 1 ) \\
   &amp; = \left ( \pmb X \hat {\pmb \beta} -  \pmb 1 (\pmb 1^t \pmb y)/n \right )^t   \left ( \pmb X \hat {\pmb \beta} -  \pmb 1 (\pmb 1^t \pmb y)/n \right )\\
   &amp; = \left ( \pmb H \pmb y-  \tfrac{1}{n} \pmb 1 \pmb 1^t \pmb y \right )^t   \left ( \pmb H \pmb y-  \tfrac{1}{n} \pmb 1 \pmb 1^t \pmb y \right ) \\
    &amp; =  \pmb y^t \left ( \pmb H  -  \tfrac{1}{n} \pmb J \right )^t   \left ( \pmb H  -  \tfrac{1}{n} \pmb J \right ) \pmb y \\
    &amp; = \pmb y^t \left ( \pmb H  -  \tfrac{1}{n} \pmb J \right )   \left ( \pmb H  -  \tfrac{1}{n} \pmb J \right ) \pmb y \\
     &amp; = \pmb y^t  \left ( \pmb H  -  \tfrac{1}{n} \pmb J \right ) \pmb y \\
\end{aligned}
\]</span></p>
<p>위의 유도식에서 다음 두 가지 성질을 이용하였다. 첫 번째 성질은 모자행렬이 사영행렬이며 모자행렬이 투영하는 공간은 일벡터 <span class="math inline">\(\pmb 1\)</span>을 포함한 공간이다. 이는 계획 행렬 <span class="math inline">\(\pmb X\)</span>의 첫 번째 열이 절편에 대한 값으로 모두 1인 것 때문이다. 따라서</p>
<p><span class="math display">\[
\begin{aligned}
\pmb H \pmb J &amp; =  \pmb H  \pmb 1 \pmb 1^t \\
   &amp; =  [ \pmb H  \pmb 1 ]  \pmb 1^t \\
  &amp; = \left [  \pmb X (\pmb X^t \pmb X)^{-1} \pmb X^t  \pmb 1 \right ] \pmb 1^t \\
  &amp; =  \pmb 1 \pmb 1^t \\
  &amp; = \pmb J  
\end{aligned}
\]</span></p>
<p>두 번째로 다음과 같이 <span class="math inline">\(\pmb J \pmb J = n \pmb J\)</span>이므로 <span class="math inline">\(\tfrac{1}{n} \pmb J\)</span>는 멱등행렬이다.</p>
<p><span class="math display">\[
\begin{aligned}
   \pmb J \pmb J &amp; =   \pmb 1 \pmb 1^t   \pmb 1 \pmb 1^t \\
     &amp; =  \pmb 1   [ \pmb 1^t  \pmb 1 ]  \pmb 1^t \\
    &amp; = \pmb 1   [ n ]  \pmb 1^t \\
    &amp; =  n \pmb 1 \pmb 1^t \\
    &amp; =  n \pmb J  
\end{aligned}
\]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
노트
</div>
</div>
<div class="callout-body-container callout-body">
<p>참고로 평균모형 <a href="lse.html#eq-meanmodel" class="quarto-xref">식&nbsp;<span>1.7</span></a> 에서 <span class="math inline">\(\pmb X = \pmb 1\)</span>으므로 이 경우 모자행렬이 다음과 같다.</p>
<p><span class="math display">\[ H_0 = \pmb 1 ({\pmb 1}^t \pmb 1)^{-1} {\pmb 1}^t = \tfrac{1}{n} \pmb J \]</span></p>
</div>
</div>
<p>다음으로 비중심 모수를 유도하자.</p>
<p><span class="math display">\[
\begin{aligned}
\pmb \mu^t \left ( \pmb H  -  \tfrac{1}{n} \pmb J \right )  \pmb \mu
  &amp; =  \pmb \beta^t  \pmb X^t \left ( \pmb H  -  \tfrac{1}{n} \pmb J \right ) \pmb X \pmb \beta  \\
  &amp; =  \pmb \beta^t  \left ( \pmb X^t \pmb H \pmb X -  \tfrac{1}{n} \pmb X^t  \pmb J \pmb X \right )  \pmb \beta  \\
&amp; =  \pmb \beta^t  \left ( \pmb X^t \pmb X -  \tfrac{1}{n} \pmb X^t  \pmb J \pmb X \right )  \pmb \beta  \\
&amp; =  \pmb \beta^t \pmb X^t  \left ( \pmb I -  \tfrac{1}{n}  \pmb J \right )  \pmb X \pmb \beta  \\
&amp; \equiv \delta(\pmb \beta)
\end{aligned}
\]</span></p>
<p>또한</p>
<p><span class="math display">\[
\begin{aligned}
r\left ( \pmb H  -  \tfrac{1}{n} \pmb J \right )  
      &amp; = tr(\pmb H) - tr \left [ \tfrac{1}{n} \pmb J \right ]  \\
      &amp; = p -\tfrac{1}{n} tr (\pmb 1 \pmb 1^t) \\
      &amp; = p -\tfrac{1}{n} tr ( \pmb 1^t \pmb 1) \\
      &amp;=  p -\tfrac{1}{n} n \\
      &amp; = p-1 \\
      &amp; = p-1
\end{aligned}
\]</span></p>
<p>위의 결과를 종합하면 회귀제곱합 <span class="math inline">\(SSR\)</span>은 다음과 같은 분포를 따른다.</p>
<p><span id="eq-distssr"><span class="math display">\[
\frac{SSR}{\sigma^2} \sim \chi^2(p-1, \lambda^2),
\tag{2.3}\]</span></span></p>
<p>위에서 비중심 모수는 다음과 같다.</p>
<p><span id="eq-noncentral"><span class="math display">\[
  \lambda^2 = \tfrac{1}{\sigma^2} \delta(\pmb \beta) =
\tfrac{1}{\sigma^2} \pmb \beta^t \pmb X^t  \left ( \pmb I -  \tfrac{1}{n}  \pmb J \right )  \pmb X \pmb \beta
\tag{2.4}\]</span></span></p>
</section>
<section id="잔차제곱합과-회귀제곱합의-독립" class="level3" data-number="2.1.3">
<h3 data-number="2.1.3" class="anchored" data-anchor-id="잔차제곱합과-회귀제곱합의-독립"><span class="header-section-number">2.1.3</span> 잔차제곱합과 회귀제곱합의 독립</h3>
<p>잔차제곱합과 회귀제곱합에서 나타난 이차형식의 두 멱등행렬의 곱은 <span class="math inline">\(\pmb 0\)</span>이다.</p>
<p><span class="math display">\[
\begin{aligned}
(\pmb I - \pmb H) \left ( \pmb H  -  \tfrac{1}{n} \pmb J \right )  
&amp; = \pmb H -  \tfrac{1}{n} \pmb J  - \pmb H \pmb H  + \tfrac{1}{n} \pmb H \pmb J \\
  &amp; = \pmb H -  \tfrac{1}{n} \pmb J  -  \pmb H  + \tfrac{1}{n}  \pmb J \\
  &amp; = \pmb 0
\end{aligned}
\]</span></p>
<p>따라서 부록의 정리에 의하여 잔차제곱합(<span class="math inline">\(SSE\)</span>)과 회귀제곱합(<span class="math inline">\(SSR\)</span>)은 서로 독립이다.</p>
</section>
<section id="총제곱합의-분포" class="level3" data-number="2.1.4">
<h3 data-number="2.1.4" class="anchored" data-anchor-id="총제곱합의-분포"><span class="header-section-number">2.1.4</span> 총제곱합의 분포</h3>
<p>총제곱합 <span class="math inline">\(SST\)</span>의 분포는 위의 결과들을 이용하면 쉽게 구할 수 있다.</p>
<p><span class="math display">\[
SST = \sum_{i=1}^n (y_i - \bar y)^2 = \pmb y^t  \left ( \pmb I -  \tfrac{1}{n}  \pmb J \right ) \pmb y
\]</span></p>
<p>위의 결과를 종합하면 회귀제곱합 <span class="math inline">\(SST\)</span>은 다음과 같은 분포를 따른다.</p>
<p><span id="eq-distsst"><span class="math display">\[
\frac{SST}{\sigma^2} \sim \chi^2(n-1, \lambda^2),
\tag{2.5}\]</span></span></p>
<p>위에서 비중심 모수 <span class="math inline">\(\lambda^2\)</span>은 식 <a href="#eq-noncentral" class="quarto-xref">식&nbsp;<span>2.4</span></a> 과 같다.</p>
</section>
</section>
<section id="모분산의-추정" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="모분산의-추정"><span class="header-section-number">2.2</span> 모분산의 추정</h2>
<p>최소제곱법을 통해서 회귀분석을 실시하였을때 우리는 적합된 회귀선이 얼마나 실제 관측값들을 잘 설명하고 있는지를 파악하는 것이 모형의 유용성을 판단하는데 중요한 작업이다. 즉, 적합된 회귀선이 관측값을 예측할 때의 변동성을 측정하는 것이 중요하다. 그 변동의 정도를 나타내는 것이 모분산 <span class="math inline">\(\sigma^2\)</span>의 추정이다.</p>
<p>식 <a href="#eq-distsse" class="quarto-xref">식&nbsp;<span>2.2</span></a> 에 나타난 잔차제곱합의 분포를 이용하면 다음과 같은 결과를 얻는다.</p>
<p><span class="math display">\[ E \left [ \frac{SSE}{\sigma^2} \right ] = n-p \]</span></p>
<p>위의 방정식에 적률법(Method of Moments)를 적용하면 모분산 <span class="math inline">\(\sigma^2\)</span>에 대한 불편추정량을 얻을 수 있다. 평균 잔차 제곱합(mean residual sum of square; <span class="math inline">\(S^2\)</span> 또는 MSE)를 다음과 같이 정의하자.</p>
<p><span id="eq-rss"><span class="math display">\[
MSE = \frac{SSE}{n-p} = \frac{\sum r^2_i}{n-p}  = \frac{\sum(y_i-\hat y_i)^2}{n-p} \equiv s^2
\tag{2.6}\]</span></span></p>
<p><span class="math inline">\(S^2=MSE\)</span>은 모분산의 불편 추정량이다.</p>
<p><span class="math display">\[ E(s^2) = E(MSE) =\sigma^2 \]</span></p>
<p>모분산의 추정량이 작을수록 관측값 <span class="math inline">\(y\)</span>의 변동 중 회귀식이 설명할 수 변동이 크다는 것을 나타낸다. 관측값들이 회귀식으로부터 멀리 떨어져 있으면 <span class="math inline">\(MSE\)</span> 는 커진다.</p>
<p>회귀계수들의 공분산을 추정하는 경우에도 <span class="math inline">\(s^2\)</span>이 사용된다.</p>
<p><span class="math display">\[ \hat V ( \hat {\pmb \beta }) = \hat \sigma^2 (\pmb X^t \pmb X)^{-1} = s^2(\pmb X^t \pmb X)^{-1} \]</span></p>
</section>
<section id="최소제곱-추정량의-성질" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="최소제곱-추정량의-성질"><span class="header-section-number">2.3</span> 최소제곱 추정량의 성질</h2>
<p>최소제곱 추정량의 분포에 대한 성질은 다음과 같다.</p>
<ul>
<li><p><span class="math inline">\(\hat {\pmb \beta} \sim N(\pmb \beta, \sigma^2 (\pmb X^t \pmb X)^{-1} )\)</span></p></li>
<li><p><span class="math inline">\(\hat {\pmb \beta}\)</span>와 <span class="math inline">\(SSE\)</span>는 독립이다.</p></li>
<li><p>잔차제곱합(<span class="math inline">\(SSE\)</span>)과 회귀제곱합(<span class="math inline">\(SSR\)</span>)은 서로 독립이다.</p></li>
<li><p><span class="math inline">\(SSE/\sigma^2\)</span>는 자유도가 <span class="math inline">\(n-p\)</span>인 카이제곱 분포를 따른다.</p></li>
<li><p><span class="math inline">\((\hat {\pmb \beta} -\pmb \beta)^t (\pmb X^t \pmb X) (\hat {\pmb \beta} -\pmb \beta) /\sigma^2\)</span> 는 자유도가 <span class="math inline">\(p\)</span>인 카이제곱분포를 따른다.</p></li>
</ul>
</section>
<section id="모형의-적합도-검정과-분산분석" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="모형의-적합도-검정과-분산분석"><span class="header-section-number">2.4</span> 모형의 적합도 검정과 분산분석</h2>
<p>회귀식을 적합하고 가장 먼저 고려해야할 사항은 적합된 회귀식이 유의한 의미를 가지는지 알아보는 것이다. 회귀식이 가지고 있는 의미는 설명변수의 변화에 따라서 반응변수가 변한다는 것이다. 따라서 회귀 모형이 유의하다는 것은 최소한 하나 이상의 설명변수가 반응변수의 변화를 예측하는데 의미가 있다는 것을 뜻한다. 모든 회귀계수의 값이 0이면 반응변수를 예측하는데 모든 설명변수가 필요가 없다는 것을 의미한다. 이러한 무의미한 모형은 앞장에서 나온 평균모형 <a href="lse.html#eq-meanmodel" class="quarto-xref">식&nbsp;<span>1.7</span></a> 이다.</p>
<p>이제 제시된 회귀식이 유의한 지에 대한 검정은 다음과 같은 두 가설 중 하나를 선택하는 것이다.</p>
<p><span class="math display">\[
H_0: \text{mean model} \quad vs. \quad H_1: \text{ not } H_0
\]</span></p>
<p>위의 가설을 바꾸어 쓰면 선형 회귀모형의 유의성 또는 적합도을 검정하는 가설이 된다.</p>
<p><span id="eq-anovahypo"><span class="math display">\[
H_0: \beta_1 = \beta_2 = \cdots = \beta_{p-1} =0 \quad vs. \quad H_1: \text{ At least one of } \beta_i \text{ is not equal to } 0
\tag{2.7}\]</span></span></p>
<p>위의 가설 <a href="#eq-anovahypo" class="quarto-xref">식&nbsp;<span>2.7</span></a> 를 검정하는 방법이 분산분석표를 이용한 F-검정이다.</p>
<p>가설 <a href="#eq-anovahypo" class="quarto-xref">식&nbsp;<span>2.7</span></a> 에서 귀무가설 <span class="math inline">\(H_0\)</span>가 참인 경우는</p>
<p><span class="math display">\[
\pmb X \pmb \beta = [ \pmb 1 ~ \pmb x_1 ~ \dots ~ \pmb x_{p-1} ]
\begin{bmatrix}
\beta_0 \\
0 \\
\vdots \\
0
\end{bmatrix}
=\beta_0 \pmb 1
\]</span></p>
<p>이 성립하여 식 <a href="#eq-noncentral" class="quarto-xref">식&nbsp;<span>2.4</span></a> 에 나타난 비중심 모수가 0이 된다.</p>
<p><span class="math display">\[  \lambda^2 = \tfrac{1}{\sigma^2} \pmb \beta^t \pmb X^t  \left ( \pmb I -  \tfrac{1}{n}  \pmb J \right )  \pmb X \pmb \beta = \tfrac{\beta_0^2}{\sigma^2}  \pmb 1^t \left ( \pmb I -  \tfrac{1}{n}  \pmb J \right )  \pmb 1 =  \pmb 0
\]</span></p>
<p>따라서 귀무가설에서는 회귀제곱합이 자유도가 <span class="math inline">\(p-1\)</span>인 중신ㅁ 카이제곱 분포를 따르게 되고 잔차제곱합과 독립이므로 다음의 통계량 <span class="math inline">\(F_0\)</span>가 자유도가 <span class="math inline">\(p-1\)</span>가ㅗ <span class="math inline">\(n-p\)</span>를 가지는 F-분포를 따른다.</p>
<p><span id="eq-fstat"><span class="math display">\[
F_0 = \frac{ SSR/(p-1)}{SSE/(n-p)} = \frac{MSR}{MSE} \sim F(p-1, n-p) \quad \text{ under } H_0
\tag{2.8}\]</span></span></p>
<p>따라서 위의 검정 통계량의 p-값이 유의수준보다 크면 적합성 검정에 대한 가설 <a href="#eq-anovahypo" class="quarto-xref">식&nbsp;<span>2.7</span></a> 의 귀무가설을 기각한다. 귀무가설의 기각은 회귀모형의 계수 중 적어도 하나는 0이 아니므로 회귀 모형이 유의하다는 의미이다.</p>
<p>위에서 안급한 F-검정을 위한 통계량들은 다음과 같은 분산분석(Analysis of Variance; ANOVA) 표를 사용하면 쉽게 계산할 수 있다.</p>
<table class="table">
<caption>적합도 검정을 위한 분산분석표</caption>
<colgroup>
<col style="width: 8%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 17%">
<col style="width: 34%">
<col style="width: 17%">
</colgroup>
<thead>
<tr class="header">
<th>요인</th>
<th>제곱합</th>
<th>자유도</th>
<th>평균제곱합</th>
<th>F-통계량</th>
<th>p-값</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>회귀</td>
<td><span class="math inline">\(SSR\)</span></td>
<td><span class="math inline">\(p-1\)</span></td>
<td><span class="math inline">\(MSR\)</span></td>
<td><span class="math inline">\(F_0 =\frac{MSR}{MSE}\)</span></td>
<td><span class="math inline">\(P(F&gt;F_0)\)</span></td>
</tr>
<tr class="even">
<td>오차</td>
<td><span class="math inline">\(SSE\)</span></td>
<td><span class="math inline">\(n-p\)</span></td>
<td><span class="math inline">\(MSE\)</span></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>전체</td>
<td><span class="math inline">\(SST\)</span></td>
<td><span class="math inline">\(n-1\)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../qmd/lse.html" class="pagination-link" aria-label="선형 회귀모형의 소개">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">선형 회귀모형의 소개</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../qmd/inference2.html" class="pagination-link" aria-label="모형의 비교">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">모형의 비교</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>