<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>통계적 예측모형 - 6&nbsp; 모형의 선택</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../references.html" rel="next">
<link href="../qmd/residual.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script type="text/javascript">
 window.MathJax = {
  tex: {
    macros: {
    RR: '{\\mathbb R}',                    // a simple string replacement
    hatmat:'{\\pmb X ({\\pmb X}^t {\\pmb X} )^{-1} {\\pmb X}^t}',
    bold: ['\\boldsymbol{#1}',1] ,     // this macro has one parameter
    pardiff: ['\\frac{\\partial#2}{\\partial#1}', 2, 'x'], // this macro has an optional parameter that defaults to 'x'
    pardifftwo: ['\\frac{\\partial#1}{\\partial#2}', 2],
    pardiffd: ['\\frac{\\partial#1}{\\partial#2^t \\partial#2}', 2],
    pardiffdd: ['\\frac{\\partial#1}{\\partial#3 \\partial#2}', 3],
    norm: ['\\lVert#1\\rVert',1]
  },
  environments: {
  braced: ["\\left\\{", "\\right\\}"]
  }
 }
};
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../qmd/modelselection.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">모형의 선택</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">통계적 예측모형</a> 
        <div class="sidebar-tools-main">
    <a href="../통계적-예측모형.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="검색"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/lse.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">선형 회귀모형의 소개</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/inference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">선형회귀에서의 추론</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/inference2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">모형의 비교</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/modeleval2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">모형의 진단</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/residual.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">관측값에 대한 진단</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/modelselection.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">모형의 선택</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_mat_basic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">행렬의 기초</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_vector_space.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">벡터공간</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_eigen_value.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">고유값과 고유벡터</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_vec_cal.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">벡터 미분</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/multivar.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">다변량 확률변수의 성질</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/quadratic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">이차형식과 제곱합의 분포</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/aic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">G</span>&nbsp; <span class="chapter-title">모형선택의 정보 기준</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">H</span>&nbsp; <span class="chapter-title">R-실습: 중회귀 모형 적합</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">I</span>&nbsp; <span class="chapter-title">R-실습: 중회귀 모형 진단</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul class="collapse">
  <li><a href="#서론" id="toc-서론" class="nav-link active" data-scroll-target="#서론"><span class="header-section-number">6.1</span> 서론</a></li>
  <li><a href="#모형선택의-측도" id="toc-모형선택의-측도" class="nav-link" data-scroll-target="#모형선택의-측도"><span class="header-section-number">6.2</span> 모형선택의 측도</a></li>
  <li><a href="#aic-와-bic" id="toc-aic-와-bic" class="nav-link" data-scroll-target="#aic-와-bic"><span class="header-section-number">6.3</span> AIC 와 BIC</a></li>
  <li><a href="#변수-선택법" id="toc-변수-선택법" class="nav-link" data-scroll-target="#변수-선택법"><span class="header-section-number">6.4</span> 변수 선택법</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-selsection" class="quarto-section-identifier"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">모형의 선택</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="서론" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="서론"><span class="header-section-number">6.1</span> 서론</h2>
<p>모형의 선택은 자료의 분석에서 고려하는 다수의 모형들(a family of models) 중에서 가장 적합한 모형(best model)을 찾는 것이다. 여기서 가장 적합하다는 의미는 다양한 기준이 있지만 일반적으로 선택된 모형의 예측력 또는 설명력이 다른 모든 모형들보다 더 좋다는 의미이다.</p>
<p>분석에서 고려하는 모형들의 집합을 모형 공간(model space)이라고 하며 이 공간에서 가장 적합한 모형을 찾는 것이 모형 선택(model selection)이다. 이 장에서 <strong>모형의 예측력 또는 설명력</strong> 을 정의하고 비교하는 방법에 대하여 배울 것이다.</p>
<p>주어진 모형 공간에서 가장 좋은 모형을 선택했을 때 다음과 같은 질문이 가능하다.</p>
<p>선택된 모형보다 더 좋은 모형이 있지 않을까? 더 좋은 모형이 주어진 모형공간에 포함되지 않을 수도 있다.</p>
<p>주어진 자료에서 반응변수와 설명변수의 관계를 더욱 잘 설명할 수 있는모형을 계속 찾는다면 결국에는 예측력을 높이기 위하여 더 많은 설명변수를 포함하는 모형을 찾게 될 것이다. 궁국적으로는 반응변수의 관측값 <span class="math inline">\(y\)</span> 와 예측값 <span class="math inline">\(\hat y\)</span>의 차이가 가장 작은 모형, 즉 설명력이 가장 좋은 모형을 선택하려는 노력을 계속한다면 <strong>과적합(overfitting)</strong> 이 발생할 수 있다.</p>
<p>과적합은 모형의 복잡도가 증가함에 따라 주어진 자료에 대한 모형의 예측력은 증가하지만 모형의 일반적인 예측의 효율은 오히려 감소하는 현상을 말한다.</p>
<p>이러한 과적합을 피하려면 모형의 복잡도와 예측력 사이의 적절한 균형을 찾아야 한다.</p>
<p>현실 세계의 상황에서는 진정한 모형이 알려지지 않거나 자료의 정확한 분포와 관계를 기술할 수 있는 모형을 파악하는 것은 매우 어렵다. 하지만 실제로 데이터를 생성하는 과정이나 현상을 정확하게 기술하는 가상의 모형이 존재한다고 가정할 수는 있다. 이렇게 자료의 분포와 관계를 정확하게 기술하는 가상의 모형을 참모형(true model)이라고 한다. 다시 강조하지만 가상의 모형이라고 말한 의미는 자료의 생성 과정을 정확하게 기술할 수 있는 모형을 구체화하여 표현하는 것이 매우 힘들기 떄문이다.</p>
<p>모형의 선택하는 또 다른 기준은 가상의 <strong>참모형에 제일 가까운 모형</strong> 을 선택하는 것이다. 우리가 생각할 수 있는 대부분의 모형 공간은 참모형을 포함하지 않는 다고 가정할 수 있다. 이러한 경우 고려하는 다수의 모형들 중에서 참모형에 가장 가까운 모형을 최적의 모형이라고 할 수 있다.</p>
</section>
<section id="모형선택의-측도" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="모형선택의-측도"><span class="header-section-number">6.2</span> 모형선택의 측도</h2>
<p>회귀분석모형의 구축을 시작할 때는 될 수 있는 한 많은 독립변수들을 고려하고 그 중에 모형에 적합한 변수들과 그렇지 않은 변수들을 구별하여 최선의 모형을 찾으려고 많은 노력을 기울인다.</p>
<p>이 절에서는 설명변수의 조합으로 만들 수 있는 다양한 모형들을 비교할 수 있는 기준과 통계적 방법에 대하여 알아보고자 한다.</p>
<p>일반적인 회귀분석모형에서 다음과 같은 선형 회귀모형을 가정한다.</p>
<p><span class="math display">\[ {\pmb y} = {\pmb X_p} {\pmb \beta}_p + \pmb e \]</span></p>
<p>오차항이 다음과 같이 서로 독립이고 등분산성을 만족한다면</p>
<p><span class="math display">\[ V(\pmb e) =\sigma^2 \pmb I_n \]</span></p>
<p>최소제곱법에 의한 회귀계수 추정량 <span class="math inline">\(\hat {\pmb \beta}_p\)</span> 다음과 같고</p>
<p><span class="math display">\[  \hat {\pmb \beta}_p = ({\pmb X}_p^t{\pmb X}_p)^{-1}{\pmb X}_p^t{\pmb y} \]</span></p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
중요
</div>
</div>
<div class="callout-body-container callout-body">
<p>이 절의 선형 회귀모형에서는 독립변수의 개수가 <span class="math inline">\(p\)</span>개인 것을 강조하기 위하여 <span class="math inline">\({\pmb X}_p\)</span> 와 <span class="math inline">\({\pmb \beta}_p\)</span> 를 사용하였다.</p>
</div>
</div>
<p>모든 가능한 회귀모형의 개수는 <span class="math inline">\(2^p-1\)</span>개이므로 <span class="math inline">\(p\)</span>가 크지 않다면 가능한 모든 회귀모형을 비교하여 하나의 모형을 선택하는 것이 좋을 것이다. 여러가지 모형들을 비교할 수 있는 모형 선택의 측도들을 알아보자.</p>
<section id="결정계수" class="level3" data-number="6.2.1">
<h3 data-number="6.2.1" class="anchored" data-anchor-id="결정계수"><span class="header-section-number">6.2.1</span> 결정계수</h3>
<p>총제곱합에서 회귀모형으로 설명할 수 있는 변동 모형 제곱합이 차지하는 부분의 비율, 즉 모형제곱합 <span class="math inline">\(SSR\)</span>을 총제곱합 <span class="math inline">\(SST\)</span>으로 나눈 비율을 결정계수(coefficient of determination)라 하며 <span class="math inline">\(R^2\)</span>으로 표현한다.</p>
<p><span id="eq-selr2"><span class="math display">\[
R^2 = \frac{SSR}{SST} =  1 -\frac{SSE}{SST}  =1- \frac{\sum^n_{i=1}(y_i-\hat y_i)^2}{ \sum^n_{i=1}(y_i - \bar y)^2}
\tag{6.1}\]</span></span></p>
<p>결정계수 <span class="math inline">\(R^2\)</span>는 언제나 0 이상 1 이하의 값을 갖는다. 회귀모형이 데이터에 아주 잘 적합되면 결정계수의 값은 1 에 가깝게 된다.</p>
<p>주의할 점은 회귀식에 독립변수를 추가하면 결정계수는 언제나 증가한다. 즉 반응변수와 관련이 없는 변수도 회귀식에 추가하면 결정계수의 값이 증가하기 때문에 결정계수로 모형을 선택하면 언제나 모든 독립변수가 모형에 들어간 가장 큰 모델이 선택된다.</p>
</section>
<section id="결정계수의-수정" class="level3" data-number="6.2.2">
<h3 data-number="6.2.2" class="anchored" data-anchor-id="결정계수의-수정"><span class="header-section-number">6.2.2</span> 결정계수의 수정</h3>
<p>수정 결정계수 <span class="math inline">\(\tilde R^2\)</span>는 독립변수의 개수가 증가함에 따라 증가하는 결정계수 <span class="math inline">\(R^2\)</span>를 보정한 모형 선택의 척도이다.</p>
<p><span id="eq-seladjr2"><span class="math display">\[
\begin{aligned}
\tilde R^2 &amp; = 1-  \frac{SSE_p/(n-p)}{SST/(n-1)} \\ \notag
  &amp; = 1 - \frac{s_p^2}{SST/(n-1)}  
\end{aligned}
\tag{6.2}\]</span></span></p>
<p>여기서 <span class="math inline">\(p\)</span>는 회귀모형에 포함된 독립변수의 개수이다.</p>
</section>
<section id="mallows-c_p" class="level3" data-number="6.2.3">
<h3 data-number="6.2.3" class="anchored" data-anchor-id="mallows-c_p"><span class="header-section-number">6.2.3</span> Mallow’s <span class="math inline">\(C_p\)</span></h3>
<p>모형의 적합도를 측정하기 위한 여러 가지 통계량중 가장 중요하고 자주 쓰이는 통계량이 평균제곱오차(mean squared error; MSE)이다 이 책에서는 평균제곱오차를 <span class="math inline">\(\Delta_p^2\)</span> 으로 표시할 것이다.</p>
<p>반응변수 <span class="math inline">\(y_i\)</span>의 평균을 <span class="math inline">\(\mu_i=E(y_i)\)</span>로 하고 독립 변수의 개수가 <span class="math inline">\(p\)</span>개인 선형회귀 모형에서 최소제곱법에 의한 예측값을 <span class="math inline">\(\hat y_{ip} = {\pmb x}_{ip}^t \hat {\pmb \beta}_p\)</span>라고 하면 MSE는 다음과 같이 주어진다.</p>
<p><span class="math display">\[
\begin{aligned}
E [ (\hat y_{ip} -\mu_i)^2 ] &amp;= E[( {\pmb x}_{ip}^t \hat {\pmb \beta}_p-\mu_i)^2 ] \\
  &amp;=  E[( {\pmb x}_{ip}^t \hat {\pmb \beta}_p -E({\pmb x}_{ip}^t \hat {\pmb \beta}_p) + E({\pmb x}_{ip}^t \hat {\pmb \beta}_p)-\mu_i)^2 ] \\
  &amp;= Var({\pmb x}_{ip}^t \hat {\pmb \beta}_p)+ [E({\pmb x}_{ip}^t \hat {\pmb \beta}_p)-\mu_i]^2 \\
  &amp;= \sigma^2 {\pmb x}_{ip}^t({\pmb X}_p^t {\pmb X}_p^t)^{-1} {\pmb x}_{ip} + ( \eta_{ip}-\mu_i)^2
\end{aligned}
\]</span></p>
<p>여기서 <span class="math inline">\(\eta_{ip} = E({\pmb x}_{ip}^t \hat {\pmb \beta}_p)\)</span>이다. 여기서 유의할 점은 반응변수 <span class="math inline">\(y_i\)</span>의 평균을 <span class="math inline">\(\mu_i\)</span>와 <span class="math inline">\(\eta_{ip}\)</span> 는 다를 수도 있으며 그 차이를 모형에 의한 편이(bias)라고 한다.</p>
<p><span class="math display">\[ E({\pmb x}_{ip}^t \hat {\pmb \beta}_p ) -\mu_i =  \eta_{ip} -\mu_i \]</span></p>
<p>이제 평균제곱오차를 구하기 위하여 각각의 관측값 <span class="math inline">\(y_1, y_2,\dots,y_n\)</span>에 대한 제곱합을 구해보자</p>
<p><span id="eq-selmse1"><span class="math display">\[
\begin{aligned}
\Delta_p^2 &amp;= \sum_i E(\hat y_{ip} -\mu_i)^2   \\
  &amp;= \sigma^2 \sum_i {\pmb x}_{ip}^t({\pmb X}_p^t {\pmb X}_p^t)^{-1} {\pmb x}_{ip} + \sum_i (\eta_{ip}-\mu_i)^2 \\ \notag
  &amp; = \sigma^2 tr( {\pmb X}_p ({\pmb X}_p^t {\pmb X}_p^t)^{-1} {\pmb X}_p^t ) + \sum_i (\eta_{ip}-\mu_i)^2 \\ \notag
  &amp;= p \sigma^2 + SSB_p
\end{aligned}
\tag{6.3}\]</span></span></p>
<p>여기서 <span class="math inline">\(SSB_p=\sum_i (\eta_{pi}-\mu_i)^2\)</span>이며 예측값의 편이들의 제곱합이다.평균제곱오차 <span class="math inline">\(\Delta_p^2\)</span> 은 모형에서 추정된 값이 실제 평균과 가까운 정도를 나타내는 측도이지만 실제로 자료를 이용하여 구할 수는 없는 양이다.</p>
<p>여기서 중요한 점은 평균제곱오차 <span class="math inline">\(\Delta_p^2\)</span> 는 분산과 편차 제곱들의 합이다.</p>
<p>실제 평균제곱오차 <span class="math inline">\(\Delta_p^2\)</span>는 계산할 수 있는 값이 아니므로 이를 적절히 추정할 수 있는 통계량으로 잔차제곱합 (SSE)를 생각해 보자. 독립 변수의 개수가 <span class="math inline">\(p\)</span>개인 선형회귀 모형에 의한 잔차제곱합을 고려하고 그 기대값을 구해보면</p>
<p><span id="eq-selmse2"><span class="math display">\[
\begin{aligned}
E(SSE_p) &amp;= E[ {\pmb y}^t ({\pmb I} - {\pmb X}_p ({\pmb X}_p^t {\pmb X}_p)^{-1}{\pmb X}_p^t) {\pmb y} ] \\ \notag
       &amp;= tr( \sigma^2 ({\pmb I} - {\pmb X}_p ({\pmb X}_p^t {\pmb X}_p)^{-1}{\pmb X}_p^t)) +
         E({\pmb y})^t  ({\pmb I} - {\pmb X}_p ({\pmb X}_p^t {\pmb X}_p)^{-1}{\pmb X}_p^t) E({\pmb y}) \\ \notag
      &amp;= \sigma^2 tr(  ({\pmb I} - {\pmb X}_p ({\pmb X}_p^t {\pmb X}_p)^{-1}{\pmb X}_p^t)) +
             E({\pmb y})^t ({\pmb I} -\pmb H_p)({\pmb I} -\pmb H_p ) E({\pmb y}) \\ \notag
         &amp;= \sigma^2 (n-p) + [E({\pmb y}) - E(\hat {\pmb y}_p)]^t [E({\pmb y}) - E(\hat {\pmb y}_p)] \\
       &amp;= \sigma^2(n-p) + SSB_p
\end{aligned}
\tag{6.4}\]</span></span></p>
<p>위의 결과는 <span class="math inline">\({\pmb I} - {\pmb X}_p ({\pmb X}_p^t {\pmb X}_p)^{-1}{\pmb X}_p^t = {\pmb I} -{\pmb H}_p\)</span>가 멱등행렬인 사실과 아래의 식을 이용하였다.</p>
<p><span class="math display">\[ \eta_p = E(\hat {\pmb y}_p) = E({\pmb X}_p^t \hat {\pmb \beta}_p) =  {\pmb X}_p ({\pmb X}_p^t {\pmb X}_p)^{-1}{\pmb X}_p^t E( {\pmb y})  = {\pmb H}_p E( {\pmb y})\]</span> 만약 <span class="math inline">\(\sigma^2\)</span>의 불편추정량을 <span class="math inline">\(\hat \sigma^2\)</span>라 하면 식 <a href="#eq-selmse1" class="quarto-xref">식&nbsp;<span>6.3</span></a> 와 <a href="#eq-selmse2" class="quarto-xref">식&nbsp;<span>6.4</span></a> 를 이용하여 다음과 같은 결과를 얻는다.</p>
<p><span id="eq-selcp2"><span class="math display">\[
\begin{aligned}
E[SSE_p -(n-2p)\hat \sigma^2] &amp; = \sigma^2(n-p) + SSB_p -(n-2p) E(\hat \sigma^2) \\ \notag  
       &amp; = p\sigma^2 +SSB_p  \\ \notag
       &amp; = \Delta_p^2
\end{aligned}
\tag{6.5}\]</span></span></p>
<p>따라서 평균제곱오차 <span class="math inline">\(\Delta_p^2\)</span>의 추정량으로 <span class="math inline">\(SSE_p -(n-2p)\hat \sigma^2\)</span> 을 사용할 수 있다. Mallow(1973)가 제안한 Mallow’s <span class="math inline">\(C_p\)</span>는 평균제곱오차를 분산의 추정량으로 나눈값 <span class="math inline">\(\Delta_p^2/\sigma^2\)</span>이며 이를 최소화는 모형을 선택할 것을 Mallow가 제안하였다.</p>
<p><span id="eq-selcp"><span class="math display">\[
C_p = \frac{SSE_p}{\hat \sigma^2 } + (2p-n)
\tag{6.6}\]</span></span></p>
<p>식 <a href="#eq-selcp" class="quarto-xref">식&nbsp;<span>6.6</span></a> 에서 주어진 <span class="math inline">\(C_p\)</span> 에서 <span class="math inline">\(\hat \sigma^2\)</span>은 고려하는 모든 변수를 포함하는 모형(full model)에서 구한 오차항 분산의 추정량이다. Mallow(1973)는 <span class="math inline">\(\Delta_p^2\)</span>이 <span class="math inline">\(SSB_p\)</span>가 0일 때, 즉 <span class="math inline">\(E(\hat {\pmb y}_p)=E({\pmb y})\)</span>일 때 최소값 <span class="math inline">\(p \sigma^2\)</span>를 같는다는 사실에 의거하여 <span class="math inline">\(C_p\)</span>와 <span class="math inline">\(p\)</span>에 대한 그림을 그리고 <span class="math inline">\(C_p\)</span>의 값이 해당하는 <span class="math inline">\(p\)</span>값에 가깝거나 작은 모형을 선택하는 탐색적 방법을 제안하였다.</p>
<p>여기서 주목할 점은 Mallow’s <span class="math inline">\(C_p\)</span> 에서 설명변수의 개수 <span class="math inline">\(p\)</span>의 개수를 크게 하면 <span class="math inline">\(SSE_p\)</span> 는 작아지지만 항 <span class="math inline">\(2p-n\)</span>은 증가하게 된다. 따라서 <span class="math inline">\(SSE_p\)</span>에 더해주는 항 <span class="math inline">\(2p-n\)</span> 은 설명변수의 증가에 따른 벌칙항(penalty term)으로 볼 수 있다.</p>
</section>
<section id="press" class="level3" data-number="6.2.4">
<h3 data-number="6.2.4" class="anchored" data-anchor-id="press"><span class="header-section-number">6.2.4</span> PRESS</h3>
<p>PRESS는 prediction error sum of square의 약자로 Cross-validation에 의거한 모형선택을 위한 척도이다. 전차분석에서 보았던 처럼 <span class="math inline">\(i\)</span>번째 관측치 <span class="math inline">\((y_i,{\pmb x}_i)\)</span>를 제외한 반응변수 벡터, 계획행렬, 회귀계수를 각각 <span class="math inline">\({\pmb y}_{-i}\)</span>, <span class="math inline">\({\pmb X}_{-i}\)</span>, <span class="math inline">\(\hat {\pmb \beta}_{-i}\)</span>와 같이 표시하고 그에 해당하는 예측값을 <span class="math inline">\(\hat y_{ip,-i}\)</span>라 하면 RESS는 다음과 같이 정의된다.</p>
<p><span id="eq-selpress"><span class="math display">\[
PRESS_p  = \frac{1}{n} \sum_{i=1}^n (y_i - \hat y_{ip,-i})^2
\tag{6.7}\]</span></span></p>
<p>여기서 잔차분석에서 유도한 것처럼</p>
<p><span class="math display">\[ y_i - \hat y_{ip,-i} = \frac{r_i}{1-h_{ii}} \]</span></p>
<p>를 이용하면 PRESS를 다음과 같이 표현할 수 있다.</p>
<p><span class="math display">\[
PRESS_p = \frac{1}{n} \sum_{i=1}^n  \left [ \frac{y_i - \hat y_{ip}}{1-h_{ii}} \right ]^2
\approx \frac{ SSE_p }{n(1-p/n)^2}
\]</span></p>
<p>위의 식 마지막 근사는 모든 <span class="math inline">\(h_{ii}\)</span>가 그 평균값 <span class="math inline">\(p/n\)</span>에 가깝다는 가정 하에 세워진 식이다.</p>
</section>
</section>
<section id="aic-와-bic" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="aic-와-bic"><span class="header-section-number">6.3</span> AIC 와 BIC</h2>
<p>통계모형을 선택하는 척도로서 가능도함수이론에 근거한 AIC(Akaike information criteria)와 베이지안 검정이론에 기초한 BIC(bayesian or schwartz information criteria)가 있다.</p>
<p>AIC와 BIC는 회귀분석뿐 아니라 일반적인 통계 모형에서 자주 사용하는 모형의 선택에 대한 척도이다. AIC와 BIC의 정의는 다음과 같다.</p>
<p><span id="eq-selbic"><span class="math display">\[
AIC =  -2 \log \ell(\hat {\pmb \theta}) + 2k
\tag{6.8}\]</span></span></p>
<p><span id="eq-selaic"><span class="math display">\[
BIC =  -2 \log \ell(\hat {\pmb \theta}) + (\log n) k
\tag{6.9}\]</span></span></p>
<p>여기서 <span class="math inline">\(k\)</span>는 모형에 포함된 모수의 총 개수 이다. <span class="math inline">\(\ell(\hat {\pmb \theta})\)</span>은 최대가능도추정량 <span class="math inline">\(\hat {\pmb \theta}\)</span>에서 계산된 로그 가능도함수이다.</p>
<p>선형모형에 대한 가능도 추정에서 식 <a href="lse.html#eq-linregloglike" class="quarto-xref">식&nbsp;<span>1.19</span></a> 에서 보았듯이 정규분포 가정 하에서 회귀모형에 대한 로그 가능도함수는 다음과 같으므로</p>
<p><span class="math display">\[
l_n(\hat { \pmb \theta} ) = l_n(\hat { \pmb \beta} ,\hat \sigma^2 )
= -\frac{n}{2}\log(2\pi) - \frac{n}{2}  - \frac{n}{2} \log \frac{SSE_p}{n}
\]</span></p>
<p>따라서 선형회귀 모형에서의 AIC와 BIC는 다음과 같이 주어진다.</p>
<p><span class="math display">\[
\begin{aligned}
AIC &amp;= n\log(2\pi) + n + n \log  \frac{SSE_p}{n} + 2(p+1) \\
BIC &amp;= n\log(2\pi) + n + n \log  \frac{SSE_p}{n} + (\log n) (p+1)
\end{aligned}
\]</span></p>
<p>여기서 <span class="math inline">\(p\)</span>는 회귀모형에 포함된 독립변수의 개수이며 오차항의 분산까지 포함하여 모수의 총 개수는 <span class="math inline">\(p+1\)</span> 이다.</p>
<p>이제 잔차제곱합 <span class="math inline">\(SSE_p\)</span> 가 작아지면 AIC 와 BIC의 <span class="math inline">\(SSE_p\)</span> 부분이 작아지지만 각 측도의 벌칙항은 증가하게 된다. 여러 개의 모형을 비교하 때 AIC, BIC 의 값이 작은 모형이 좋은 모형이라고 할 수 있다. 또한 주목할 점은 AIC, BIC 의 벌칙항이 다르며 특히 BIC 의 벌칙항에 표본의 개수 <span class="math inline">\(n\)</span> 이 로그스케일로 포함되어 있다.</p>
<p>AIC 와 BIC 에 대한 이론적인 설명은 <a href="aic.html" class="quarto-xref"><span>부록 G</span></a> 에 제시되어 있으니 참고하자.</p>
</section>
<section id="변수-선택법" class="level2" data-number="6.4">
<h2 data-number="6.4" class="anchored" data-anchor-id="변수-선택법"><span class="header-section-number">6.4</span> 변수 선택법</h2>
<p>주어진 설명변수들 중에 반응변수에 유의한 영향을 미치는 변수들을 단계적으로 선택하는 방법(variable selection procedure)은 다음과 같이 세 종류의 방법이 있다.</p>
<ul>
<li><p>Forward selection: Forward selection 방법은 회귀모형에 독립변수를 하나 씩 추가하는 방법이다. 첫 번째 추가하는 변수는 설명변수가 한 개인 모형 중에 결정계수 <span class="math inline">\(R^2\)</span>(또는 다른 측도)이 가장 큰 변수를 선택하며 두번째 부터는 추가되었을 때 <span class="math inline">\(R^2\)</span>의 증가가 가장 큰 값을 선택하게 된다. 변수의 추가가 멈추는 조건은 추가된 변수가 주어진 신뢰수준에서 유의하지 않을 때이다.</p></li>
<li><p>Backward elimination: Backward elimination 방법은 모든 설명변수를 포함한 가장 큰 회귀모형(full model)에서 설명변수를 하나 씩 제거하는 방법이다. 제거하는 변수의 선택은 변수가 제거되었을 때 <span class="math inline">\(R^2\)</span>의 감소가 가장 작은 값을 선택하게 된다.</p></li>
<li><p>Stepwise: Stepwise는 Forward selection과 Backward elimination을 조합하여 변수의 추가와 제거가 모두 가능한 방법이다.</p></li>
</ul>
<p>변수선택법은 이 방법이 제안되었을 당시 매우 유용한 방법으로 여겨졌다. 그러나 변수선택법의 무리한 남용 등 여러 가지 단점들로 인하여 조심해서 사용해야 한다는 것이 현재의 공통된 의견이다. 변수선택법의 이용과 그 유의사항은 다음과 같이 요약할 수 있다.</p>
<ul>
<li><p>미숙한 이용자에 의해 남용될 수 있다.</p></li>
<li><p>다중공선성이 존재할 때 불안정하다.</p></li>
<li><p>Stepwise는 주어진 추가와 제거 시 사용되는 유의수준에 따라 최적의 모형이 다를 수 있다.</p></li>
<li><p>모든 가능한 회귀 모형(All possible regressions)을 사용하는 것이 대안이 될 수 있다.</p></li>
<li><p>과적합(overfitting)의 위험성이 크다.</p></li>
<li><p>변수의 추가나 제거에 통계적 검정법을 쓰는데 여러 가지 위험성이 존재한다 (예로 다중비교 문제)</p></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../qmd/residual.html" class="pagination-link" aria-label="관측값에 대한 진단">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">관측값에 대한 진단</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../references.html" class="pagination-link" aria-label="References">
        <span class="nav-page-text">References</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>