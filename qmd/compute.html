<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>통계적 예측모형 - 9&nbsp; 최소제곱 추정량의 계산</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../qmd/extension.html" rel="next">
<link href="../qmd/ancova.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script type="text/javascript">
 window.MathJax = {
  tex: {
    macros: {
    RR: '{\\mathbb R}',                    // a simple string replacement
    hatmat:'{\\pmb X ({\\pmb X}^t {\\pmb X} )^{-1} {\\pmb X}^t}',
    bold: ['\\boldsymbol{#1}',1] ,     // this macro has one parameter
    pardiff: ['\\frac{\\partial#2}{\\partial#1}', 2, 'x'], // this macro has an optional parameter that defaults to 'x'
    pardifftwo: ['\\frac{\\partial#1}{\\partial#2}', 2],
    pardiffd: ['\\frac{\\partial#1}{\\partial#2^t \\partial#2}', 2],
    pardiffdd: ['\\frac{\\partial#1}{\\partial#3 \\partial#2}', 3],
    norm: ['\\lVert#1\\rVert',1]
  },
  environments: {
  braced: ["\\left\\{", "\\right\\}"]
  }
 }
};
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../qmd/compute.html"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">최소제곱 추정량의 계산</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">통계적 예측모형</a> 
        <div class="sidebar-tools-main">
    <a href="../통계적-예측모형.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="검색"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/lse.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">선형 회귀모형의 소개</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/inference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">선형회귀에서의 추론</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/inference2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">모형의 비교</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/modeleval2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">모형의 진단</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/residual.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">관측값에 대한 진단</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/modelselection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">모형의 선택</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/anova.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">분산분석 모형</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/ancova.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">공분산분석</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/compute.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">최소제곱 추정량의 계산</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/extension.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">회귀모형의 확장</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_mat_basic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">행렬의 기초</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_vector_space.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">벡터공간</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_eigen_value.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">고유값과 고유벡터</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_matrix_decomp.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">행렬의 분해</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_vec_cal.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">벡터 미분</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/multivar.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">다변량 확률변수의 성질</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/quadratic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">G</span>&nbsp; <span class="chapter-title">이차형식과 제곱합의 분포</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/aic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">H</span>&nbsp; <span class="chapter-title">모형선택의 정보 기준</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">I</span>&nbsp; <span class="chapter-title">R-실습: 중회귀 모형 적합</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">J</span>&nbsp; <span class="chapter-title">R-실습: 중회귀 모형 진단</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">K</span>&nbsp; <span class="chapter-title">R-실습: 관측값에 대한 진단</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">L</span>&nbsp; <span class="chapter-title">R-실습: 모형의 선택</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-05.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">M</span>&nbsp; <span class="chapter-title">R-실습: 분산분석 모형</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul class="collapse">
  <li><a href="#촐레스키-분해의-이용" id="toc-촐레스키-분해의-이용" class="nav-link active" data-scroll-target="#촐레스키-분해의-이용"><span class="header-section-number">9.1</span> 촐레스키 분해의 이용</a></li>
  <li><a href="#qr-분해의-이용" id="toc-qr-분해의-이용" class="nav-link" data-scroll-target="#qr-분해의-이용"><span class="header-section-number">9.2</span> QR 분해의 이용</a></li>
  <li><a href="#svd-을-이용" id="toc-svd-을-이용" class="nav-link" data-scroll-target="#svd-을-이용"><span class="header-section-number">9.3</span> SVD 을 이용</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-compute" class="quarto-section-identifier"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">최소제곱 추정량의 계산</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>이제 선형모형에서 회귀계수를 구하는 계산 방법에 대하여 알아보자. 최소제곱법(동시에 최대 가능도 추정법)에 의한 회귀게수의 추정치를 구하려면 다음과 같은 최적화 문제를 풀어야한다.</p>
<p><span id="eq-comp-crit"><span class="math display">\[
\underset{\pmb  \beta}{\min} \norm{ \pmb  y - \pmb  X \pmb  \beta}^2
\tag{9.1}\]</span></span></p>
<p>위의 최적화 문제로 부터 유도된 회귀계수에 대한 정규 방정식(normal equation)은 다음과 같다.</p>
<p><span id="eq-comp-lse"><span class="math display">\[
{\pmb  X}^t \pmb  X \pmb  \beta = \pmb  X^t \pmb  y
\tag{9.2}\]</span></span></p>
<p><a href="#eq-comp-lse" class="quarto-xref">식&nbsp;<span>9.2</span></a> 에 대한 해를 구하는 경우 대수적으로는 <span class="math inline">\(\hat { \pmb  \beta} = ({\pmb  X}^t \pmb  X )^{-1} \pmb  X^t \pmb  y\)</span>로 표시하지만 실제 계산에서 역행렬 <span class="math inline">\(({\pmb  X}^t \pmb  X )^{-1}\)</span>을 실제로 구하지는 않는다. <a href="#eq-comp-lse" class="quarto-xref">식&nbsp;<span>9.2</span></a> 에서 나타난 것과 같은 선형방정식을 푸는 계산적 방법은 가우스 소거법(Gauss elimination ), 교환 연산(sweep operator) 등에 의한 전통적인 방법들이 있다. 교환 연산(sweep operator) 방법은 SAS 프로그램에서 최소제곱법을 푸는 방법으로 사용된다. 이러한 전통적인 방법들은 가우스 소거법에 근거하여 핼과 열 연산에 의한 소거법을 기반으로 한다. 하지만 최근에 나온 통계 계산 패키지에서는 소거법을 사용하지 않는다.</p>
<p>이 장에서는 최근 통계 계산 프로그램이 사용하는 행렬 분해에 의한 방법을 살펴보고자 한다. 다음에 나오는 방법들은 계획행렬 <span class="math inline">\(\pmb  X\)</span>가 최대 계수(full rank)가 아닌 경우에도 적용할 수 있지만 여기서는 최대 계수인 경우만 고려하겠다.</p>
<p>아래 방법들을 공부하기 전에 <a href="math_matrix_decomp.html" class="quarto-xref"><span>부록 D</span></a> 에 제시된 행렬의 분해 방법을 먼저 공부하자.</p>
<section id="촐레스키-분해의-이용" class="level2" data-number="9.1">
<h2 data-number="9.1" class="anchored" data-anchor-id="촐레스키-분해의-이용"><span class="header-section-number">9.1</span> 촐레스키 분해의 이용</h2>
<p>방정식 <a href="#eq-comp-lse" class="quarto-xref">식&nbsp;<span>9.2</span></a> 에서 완쪽 항에 있는 <span class="math inline">\(\pmb  A = {\pmb  X}^t \pmb  X\)</span> 가 양정치 행렬이라고 하자. 양정치 행렬 A은 다음과 같이 유일하게 촐레스키 분해(Cholesky decomposition)가 가능하다.</p>
<p><span id="eq-comp-chol"><span class="math display">\[
\pmb  A = {\pmb  X}^t \pmb  X = \pmb  L \pmb  L^t
\tag{9.3}\]</span></span></p>
<p>위의 분해에서 행렬 <span class="math inline">\(\pmb  L\)</span>은 양수의 대각원소를 가지는 하삼각 행렬(lower triangular matrix)이다.</p>
<p>이제 촐레스키 분해를 정규 방정식에 적용해보자.</p>
<p><span class="math display">\[   \pmb  L \pmb  L^t \pmb  \beta = \pmb  X^t \pmb  y \]</span></p>
<p>위의 식에서 <span class="math inline">\(\pmb  L^t \pmb  \beta = \pmb  \beta_*\)</span>라고 하면 다음과 같은 방정식을 얻게 되고 이 방정식은 행렬 <span class="math inline">\(\pmb  L\)</span>이 하삼각 행렬이기 때문에 대수적으로 축차식을 이용하여 쉽게 해 <span class="math inline">\(\hat {\pmb  \beta}_*\)</span>를 얻을 수 있다.</p>
<p><span class="math display">\[ \pmb  L \pmb  \beta_* = \pmb  X^t \pmb  y \]</span></p>
<p>다음으로 관계식 <span class="math inline">\(\pmb  L^t \pmb  \beta = \pmb  \beta_*\)</span> 이용하여 다음의 방정식을 풀면 회귀계수의 추정치 <span class="math inline">\(\hat { \pmb  \beta}\)</span>를 얻게 된다. 아래의 방정식 또한 <span class="math inline">\(\pmb  L^t\)</span>가 상삼각 행렬이기 때문에 축차적인 계산이 가능하다.</p>
<p><span class="math display">\[ \pmb  L^t \pmb  \beta = \hat {\pmb  \beta}_*\]</span></p>
</section>
<section id="qr-분해의-이용" class="level2" data-number="9.2">
<h2 data-number="9.2" class="anchored" data-anchor-id="qr-분해의-이용"><span class="header-section-number">9.2</span> QR 분해의 이용</h2>
<p>차원이 <span class="math inline">\(n \times p\)</span>인 계획 행렬 <span class="math inline">\(\pmb  X\)</span>의 QR 분해가 다음과 같이 주어졌다고 하자. <span class="math inline">\(rank(\pmb  X)=p&lt; n\)</span> 이라고 가정하자.</p>
<p><span class="math display">\[  \pmb  X =\pmb  Q_1 \pmb  R_1 \]</span> 위의 QR 분해에서 <span class="math inline">\(\pmb  Q_1\)</span>는 <span class="math inline">\(p\)</span> 개의 직교하는 열을 가진 <span class="math inline">\(n \times p\)</span> 행렬이다 (<span class="math inline">\(\pmb  Q_1^t \pmb  Q_1= \pmb  I\)</span>). 또한 행렬 <span class="math inline">\(\pmb  R_1\)</span>은 차원이 <span class="math inline">\(p \times p\)</span>인 상삼각 행렬(upper diagonal matrix)이다.</p>
<p>그러면 행렬 <span class="math inline">\(\pmb  X\)</span>는 다음과 같은 확장된 분해를 가진다.</p>
<p><span class="math display">\[
\pmb   X = \pmb  Q \pmb  R =  
\begin{bmatrix} \pmb  Q_1 &amp; \pmb  Q_2  \end{bmatrix} \begin{bmatrix} \pmb  R_1 \\ \pmb  0
\end{bmatrix}
\]</span></p>
<p>위에서 <span class="math inline">\(\pmb  Q_2\)</span> 는 행렬 <span class="math inline">\(\pmb  Q_1\)</span>의 열들과 직교하는 <span class="math inline">\(n-p\)</span> 개의 추가 정규직교 벡터들로 이루어진 행렬이다. <span class="math inline">\(\pmb  Q_1\)</span>과 <span class="math inline">\(\pmb  Q_2\)</span>는 각각 <span class="math inline">\(n \times p\)</span>, <span class="math inline">\(n \times (n-p)\)</span>의 행렬이다. 따라서 행렬 <span class="math inline">\(\pmb  Q = [\pmb  Q_1 ~\pmb  Q_2]\)</span>는 <span class="math inline">\(n \times n\)</span> 직교행렬이다 (<span class="math inline">\(\pmb  Q^t \pmb  Q = \pmb  Q \pmb  Q^t = \pmb  I\)</span>).</p>
<p>또한 <span class="math inline">\(\pmb  R\)</span>는 <span class="math inline">\(n \times p\)</span> 이며 <span class="math inline">\(\pmb  0\)</span>은 차원이 <span class="math inline">\((n-p) \times p\)</span>인 영행렬이다.</p>
<p><span class="math display">\[
\pmb  R =
\begin{bmatrix}
\pmb  R_1 \\
\pmb  0
\end{bmatrix}
\]</span></p>
<p>이제 <span class="math inline">\(\pmb  Q^t \pmb  Q =\pmb  I\)</span>를 이용하여 잔차제곱합 <span class="math inline">\(\norm{ \pmb  y-\pmb  X \pmb  \beta}^2\)</span>를 다음과 같이 분해할 수 있다.</p>
<p><span class="math display">\[
\begin{aligned}
\norm{ \pmb  y-\pmb  X \pmb  \beta}^2 &amp; = (\pmb  y-\pmb  X \pmb  \beta)^t (\pmb  y-\pmb  X\pmb  \beta) \notag \\
  &amp; =(\pmb  y-\pmb  X \pmb  \beta)^t \pmb  Q \pmb  Q^t (\pmb  y-\pmb  X \pmb  \beta) \notag \\
  &amp; = (\pmb  Q^t \pmb  y-\pmb  Q^t \pmb  X \pmb  \beta)^t  (\pmb  Q^t  \pmb  y-\pmb  Q^t  \pmb  X \pmb  \beta) \notag \\
  &amp; =(\pmb  c -\pmb  R \pmb  \beta)^t  (\pmb  c -\pmb  R \pmb  \beta) \notag \\
  &amp; =  
  \left (
  \begin{bmatrix}
  \pmb  c_1 \\
  \pmb  c_2
  \end{bmatrix}
  -
  \begin{bmatrix}
  \pmb  R_1 \\
  \pmb  0
  \end{bmatrix}
  \pmb  \beta
  \right )^t
   \left (
  \begin{bmatrix}
  \pmb  c_1 \\
  \pmb  c_2
  \end{bmatrix}
  -
  \begin{bmatrix}
  \pmb  R_1 \\
  \pmb  0
  \end{bmatrix}
  \pmb  \beta
  \right ) \notag \\
  &amp; = (\pmb  c_1 -\pmb  R_1 \pmb  \beta)^t  (\pmb  c_1 -\pmb  R_1 \pmb  \beta) + \pmb  c_2^t \pmb  c_2 \notag \\
  &amp; = \norm{ \pmb  c_1 - \pmb  R_1 \pmb  \beta }^2 + \norm{\pmb  c_2}^2
\end{aligned}
\]</span></p>
<p>결과를 요약하면 다음과 같은 분해를 얻는다.</p>
<p><span id="eq-decompres"><span class="math display">\[
\norm{ \pmb  y-\pmb  X \pmb  \beta}^2 = \norm{ \pmb  c_1 - \pmb  R_1 \pmb  \beta }^2 + \norm{\pmb  c_2}^2
\tag{9.4}\]</span></span></p>
<p>여기서</p>
<p><span class="math display">\[
\pmb  c= \pmb  Q^t \pmb  y=
\begin{bmatrix}
   \pmb  Q_1^t \\
   \pmb  Q_2^t
   \end{bmatrix} \pmb  y
   =
   \begin{bmatrix}
   \pmb  Q_1^t \pmb  y  \\
   \pmb  Q_2^t \pmb  y
   \end{bmatrix}
   = \begin{bmatrix}
   \pmb  c_1 \\
   \pmb  c_2
\end{bmatrix}  
\]</span></p>
<p>위의 <a href="#eq-decompres" class="quarto-xref">식&nbsp;<span>9.4</span></a> 를 보면 벡터 <span class="math inline">\(\pmb  c_2= \pmb  Q_2^t \pmb  y\)</span>는 <span class="math inline">\(\pmb  \beta\)</span>와 관계가 없으므로 잔차제곱합 <span class="math inline">\(\norm{ \pmb  y-\pmb  X \pmb  \beta}^2\)</span> 을 최소화하는 <span class="math inline">\(\pmb  \beta\)</span>는 <span class="math inline">\(\norm{ \pmb  c_1 - \pmb  R_1 \pmb  \beta }^2\)</span>을 0으로 만드는 것이다. 즉 <span class="math inline">\(\pmb  R_1 \pmb  \beta =\pmb  c_1\)</span>를 만족하는 <span class="math inline">\(\pmb  \beta\)</span>가 최소제곱 추정량이다.</p>
<p><span class="math display">\[
\\pmbin_{\pmb  \beta} \norm{ \pmb  y-\pmb  X \pmb  \beta}^2 = \\pmbin_{\pmb  \beta} \norm{ \pmb  c_1 - \pmb  R_1 \pmb  \beta }^2 +  \norm{\pmb  c_2}^2
\]</span></p>
<p><span class="math inline">\(\pmb  X\)</span>가 완전계수 행렬이므로 상삼각행렬인 <span class="math inline">\(\pmb  R_1\)</span>도 완전계수 행렬이다. 따라서 방정식 <span class="math inline">\(\pmb  R_1 \pmb  \beta = \pmb  c_1\)</span>는 유일한 해는 상삼각행렬의 성질을 이용하여 축차식으로 쉽게 구할 수 있다.</p>
<p><span class="math display">\[ \hat {\pmb  \beta} =\pmb  R_1^{-1} \pmb  c_1 \]</span></p>
<p>추정량은 <span class="math inline">\(\hat {\pmb  \beta}\)</span>은 실제 역행렬을 구하지 않고 구할 수 있다.</p>
<p>참고로 잔차제곱합 <span class="math inline">\(SSE\)</span>는 다음과 같이 계산된다.</p>
<p><span class="math display">\[ SSE = \norm{ \pmb  y-\pmb  X \hat {\pmb  \beta}}^2 = \norm{\pmb  c_2}^2 = \pmb  y^t \pmb  Q_2 \pmb  Q_2^t \pmb  y \]</span></p>
</section>
<section id="svd-을-이용" class="level2" data-number="9.3">
<h2 data-number="9.3" class="anchored" data-anchor-id="svd-을-이용"><span class="header-section-number">9.3</span> SVD 을 이용</h2>
<p>이제 최소제곱법을 SVD (Singular Value Decomposition) 으로 푸는 방법을 살펴보자. 차원이 <span class="math inline">\(n \times p\)</span>인 계획 행렬 <span class="math inline">\(\pmb  X\)</span> 이 주어지고 <span class="math inline">\(rank(\pmb  X)=p&lt; n\)</span> 이라고 가정하자.</p>
<p>이제 계획행렬 <span class="math inline">\(\pmb  X\)</span> 은 SVD 를 이용하여 다음과 같이 분해할 수 있다.</p>
<p><span class="math display">\[  \pmb  X = \pmb  U \pmb  R  \pmb  V^t\]</span> 위의 분해에서 각 행렬의 특성은 다음과 같다.</p>
<ul>
<li><span class="math inline">\(\pmb  U\)</span>: <span class="math inline">\(n \times n\)</span> 직교행렬</li>
<li><span class="math inline">\(\pmb  V\)</span>: <span class="math inline">\(p \times p\)</span> 직교행렬</li>
</ul>
<p><span class="math inline">\(\pmb  R\)</span>은 <span class="math inline">\(n \times p\)</span> 행렬이며 윗 부분 <span class="math inline">\(p \times p\)</span> 행렬 <span class="math inline">\(R_1\)</span>은 대각 행렬이다. <span class="math inline">\(\pmb  R\)</span>의 아래 부분 <span class="math inline">\((n-p) \times p\)</span>는 영행렬이다.</p>
<p><span class="math display">\[
\pmb  R =
\begin{bmatrix}
\pmb  R_1 \\
\pmb  0
\end{bmatrix}
\quad
\pmb  R_1 = diag(r_1, r_2, \dots, r_p)
\]</span></p>
<p>따라서 계획행렬의 분해는 다음과 같이 축소할 수 있다.</p>
<p><span id="eq-svd"><span class="math display">\[
\pmb  X = \pmb  U \pmb  R  \pmb  V^t =
\begin{bmatrix}
\pmb  U_1 &amp; \pmb  U_2
\end{bmatrix}
\begin{bmatrix}
\pmb  R_1 \\
\pmb  0
\end{bmatrix}
\pmb  V^t
= \pmb  U_1 \pmb  R_1  \pmb  V^t
\tag{9.5}\]</span></span></p>
<p>위의 <a href="#eq-svd" class="quarto-xref">식&nbsp;<span>9.5</span></a> 에서 행렬 <span class="math inline">\(\pmb  U_1\)</span>은 <span class="math inline">\(n \times p\)</span>, <span class="math inline">\(\pmb  U_2\)</span>은 <span class="math inline">\(n \times (n-p)\)</span> 행렬이며 <span class="math inline">\(\pmb  U_1^t \pmb  U_1 = \pmb  I\)</span>, <span class="math inline">\(\pmb  U_2^t \pmb  U_2 = \pmb  I\)</span> 이다.</p>
<p>이제 최소제곱법의 해를 SVD 로 구해보자.</p>
<p><span class="math display">\[
\begin{aligned}
\norm{ \pmb  y-\pmb  X \pmb  \beta}^2 &amp; = (\pmb  y-\pmb  X \pmb  \beta)^t (\pmb  y-\pmb  X\pmb  \beta) \\
  &amp; = (\pmb  y-\pmb  U  \pmb  R   \pmb  V^t \pmb  \beta)^t (\pmb  y-\pmb  U  \pmb  R   \pmb  V^t \pmb  \beta) \\
  &amp; =  (\pmb  y-\pmb  U  \pmb  R   \pmb  V^t \pmb  \beta)^t \pmb  U   \pmb  U ^t (\pmb  y-\pmb  U  \pmb  R   \pmb  V^t \pmb  \beta) \\
  &amp; =  (\pmb  U ^t \pmb  y- \pmb  U ^t \pmb  U  \pmb  R   \pmb  V^t \pmb  \beta)^t    (\pmb  U ^t \pmb  y-\pmb  U ^t \pmb  U  \pmb  R   \pmb  V^t \pmb  \beta) \\
  &amp; =  (\pmb  U ^t \pmb  y-  \pmb  R   \pmb  V^t \pmb  \beta)^t    (\pmb  U ^t \pmb  y- \pmb  R   \pmb  V^t \pmb  \beta) \\
  &amp; = \norm{ \pmb  U ^t \pmb  y-  \pmb  R   \pmb  V^t \pmb  \beta}^2 \\
  &amp; = \norm{ \pmb  c -  \pmb  R   \pmb  \beta_*}^2  \\
    &amp; =  
  \left (
  \begin{bmatrix}
  \pmb  c_1 \\
  \pmb  c_2
  \end{bmatrix}
  -
  \begin{bmatrix}
  \pmb  R_1 \\
  \pmb  0
  \end{bmatrix}
  \pmb  \beta_*
  \right )^t
   \left (
  \begin{bmatrix}
  \pmb  c_1 \\
  \pmb  c_2
  \end{bmatrix}
  -
  \begin{bmatrix}
  \pmb  R_1 \\
  \pmb  0
  \end{bmatrix}
  \pmb  \beta_*
  \right )  \\
&amp; =  (\pmb  c_1 -\pmb  R_1 \pmb  \beta_*)^t  (\pmb  c_1 -\pmb  R_1 \pmb  \beta_*) + \pmb  c_2^t \pmb  c_2  \\
  &amp; = \norm{ \pmb  c_1 - \pmb  R_1 \pmb  \beta_* }^2 + \norm{\pmb  c_2}^2
\end{aligned}
\]</span></p>
<p>이제 위의 분해에서 다음과 같이 새로운 벡터를 정의한다.</p>
<p><span id="eq-svdpara"><span class="math display">\[
\pmb  c = \pmb  U^t \pmb  y,  \quad \pmb  \beta_* = \pmb  V^t \pmb  \beta
\tag{9.6}\]</span></span></p>
<p>그리고</p>
<p><span class="math display">\[
\pmb  c= \pmb  U^t \pmb  y=
\begin{bmatrix}
   \pmb  U_1^t \\
   \pmb  U_2^t
   \end{bmatrix} \pmb  y
   =
   \begin{bmatrix}
   \pmb  U_1^t \pmb  y  \\
   \pmb  U_2^t \pmb  y
   \end{bmatrix}
   = \begin{bmatrix}
   \pmb  c_1 \\
   \pmb  c_2
\end{bmatrix}  
\]</span></p>
<p>이제 QR 분해와 유사하게 최소제곱의 오차제곱합은 다음과 같이 분해된다.</p>
<p><span id="eq-svdlse"><span class="math display">\[
\norm{ \pmb  y-\pmb  X \pmb  \beta}^2  =
\norm{ \pmb  c_1 - \pmb  R_1 \pmb  \beta_* }^2 + \norm{\pmb  c_2}^2
=\sum_{i=1}^p (c_{1i} - r_i \beta_{*i})^2 + \norm{\pmb  c_2}^2
\tag{9.7}\]</span></span></p>
<p>위의 분해 <a href="#eq-svdlse" class="quarto-xref">식&nbsp;<span>9.7</span></a> 는 행렬 <span class="math inline">\(\pmb  R_1\)</span>이 대각행렬임을 이용한 것이다. 이제 <a href="#eq-svdlse" class="quarto-xref">식&nbsp;<span>9.7</span></a> 를 최소화하는 벡터 <span class="math inline">\(\hat {\pmb  \beta}_*\)</span> 의 원소들은 다음과 같이 구할 수 있고</p>
<p><span class="math display">\[ \hat \beta_{*i} =\frac{ c_{1i}}{r_i}, \quad i=1,2,\dots,p \]</span></p>
<p>최종적으로 <a href="#eq-svdpara" class="quarto-xref">식&nbsp;<span>9.6</span></a> 의 관계를 이용하면 최소제곱 추정량은 다음과 같이 주어진다.</p>
<p><span class="math display">\[ \hat {\pmb  \beta} = \pmb  V \hat {\pmb  \beta}_* \]</span> 참고로 QR 분해 방법과 유사하게 잔차제곱합 <span class="math inline">\(SSE\)</span>는 다음과 같이 계산된다.</p>
<p><span class="math display">\[ SSE = \norm{ \pmb  y-\pmb  X \hat {\pmb  \beta}}^2 = \norm{\pmb  c_2}^2 = \pmb  y^t \pmb  U_2 \pmb  U_2^t \pmb  y \]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
노트
</div>
</div>
<div class="callout-body-container callout-body">
<p>위에서 논의한 촐레스키, QR, SVD 를 이용한 최소제곱 추정량 <span class="math inline">\(\hat \beta\)</span>를 구하는 방법은 계획행렬이 완전 계수가 아닌 경우에도 (<span class="math inline">\(rank(X)&lt;p\)</span>) 쉽게 적용할 수 있다.</p>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../qmd/ancova.html" class="pagination-link" aria-label="공분산분석">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">공분산분석</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../qmd/extension.html" class="pagination-link" aria-label="회귀모형의 확장">
        <span class="nav-page-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">회귀모형의 확장</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>