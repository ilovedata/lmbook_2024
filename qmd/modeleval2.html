<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>4&nbsp; 모형의 진단 – 통계적 예측모형</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../qmd/residual.html" rel="next">
<link href="../qmd/inference2.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-a08d9001fe0711adfabc365c1b400f34.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script type="text/javascript">
 window.MathJax = {
  tex: {
    macros: {
    RR: '{\\mathbb R}',                    // a simple string replacement
    hatmat:'{\\pmb X ({\\pmb X}^t {\\pmb X} )^{-1} {\\pmb X}^t}',
    bold: ['\\boldsymbol{#1}',1] ,     // this macro has one parameter
    pardiff: ['\\frac{\\partial#2}{\\partial#1}', 2, 'x'], // this macro has an optional parameter that defaults to 'x'
    pardifftwo: ['\\frac{\\partial#1}{\\partial#2}', 2],
    pardiffd: ['\\frac{\\partial#1}{\\partial#2^t \\partial#2}', 2],
    pardiffdd: ['\\frac{\\partial#1}{\\partial#3 \\partial#2}', 3],
    norm: ['\\lVert#1\\rVert',1]
  },
  environments: {
  braced: ["\\left\\{", "\\right\\}"]
  }
 }
};
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../qmd/modeleval2.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">모형의 진단</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="검색" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">통계적 예측모형</a> 
        <div class="sidebar-tools-main">
    <a href="../통계적-예측모형.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="검색"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/lse.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">선형 회귀모형의 소개</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/inference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">선형회귀에서의 추론</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/inference2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">모형의 비교</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/modeleval2.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">모형의 진단</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/residual.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">관측값에 대한 진단</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/modelselection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">모형의 선택</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/anova.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">분산분석 모형</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/ancova.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">공분산분석</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/compute.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">최소제곱 추정량의 계산</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/extension.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">회귀모형의 확장</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/glm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">일반화 선형모형</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_mat_basic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">행렬의 기초</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_vector_space.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">벡터공간</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_eigen_value.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">고유값과 고유벡터</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_matrix_decomp.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">행렬의 분해</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/math_vec_cal.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">벡터 미분</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/multivar.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">다변량 확률변수의 성질</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/quadratic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">G</span>&nbsp; <span class="chapter-title">이차형식과 제곱합의 분포</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/mle.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">H</span>&nbsp; <span class="chapter-title">지수군 분포</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/aic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">I</span>&nbsp; <span class="chapter-title">모형선택의 정보 기준</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">J</span>&nbsp; <span class="chapter-title">R-실습: 중회귀 모형 적합</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">K</span>&nbsp; <span class="chapter-title">R-실습: 중회귀 모형 진단</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">L</span>&nbsp; <span class="chapter-title">R-실습: 관측값에 대한 진단</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">M</span>&nbsp; <span class="chapter-title">R-실습: 모형의 선택</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/practice-05.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">N</span>&nbsp; <span class="chapter-title">R-실습: 분산분석 모형</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul class="collapse">
  <li><a href="#등분산성-가정의-위반" id="toc-등분산성-가정의-위반" class="nav-link active" data-scroll-target="#등분산성-가정의-위반"><span class="header-section-number">4.1</span> 등분산성 가정의 위반</a></li>
  <li><a href="#변수변환" id="toc-변수변환" class="nav-link" data-scroll-target="#변수변환"><span class="header-section-number">4.2</span> 변수변환</a></li>
  <li><a href="#다중공선성" id="toc-다중공선성" class="nav-link" data-scroll-target="#다중공선성"><span class="header-section-number">4.3</span> 다중공선성</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-modeleval" class="quarto-section-identifier"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">모형의 진단</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="등분산성-가정의-위반" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="등분산성-가정의-위반"><span class="header-section-number">4.1</span> 등분산성 가정의 위반</h2>
<p>일반적인 회귀분석모형에서 <span class="math display">\[ \pmb y = \pmb X \pmb \beta + \pmb e \]</span></p>
<p>오차항이 다음과 같이 서로 독립이고 등분산성을 만족한다면 <span class="math display">\[ var(\pmb e) =\sigma^2 \pmb I_n \]</span></p>
<p>최소제곱법에 의한 회귀계수 추정량 <span class="math inline">\(\hat  {\pmb \beta}\)</span> 다음과 같고</p>
<p><span class="math display">\[  \hat {\pmb \beta}  = (\pmb X^t\pmb X)^{-1}\pmb X^t\pmb y \]</span></p>
<p>이는 최소분산선형추정량(BLUE)이다. 만약에 오차항에 대한 가정이 만족하지 않는다면 최소제곱법 추정량 <span class="math inline">\(\hat {\pmb \beta}\)</span>의 최적성이 유지되는가에 대한 질문이 생기게 된다.</p>
<p>여기서 오차항의 분산에 대하여 좀더 일반적인 모형을 생각해보자. 가장 일반적인 모형은 다음과 같은 임의의 양정치행렬(positive definite matrix) <span class="math inline">\(\pmb V\)</span>가 오차항의 공분산 행렬인 경우이다.</p>
<p><span class="math display">\[ Var(\pmb e) = \pmb V \]</span> 가장 일반적인 경우를 고려하기 전에 전형적인 가정을 약간 벗어나면서 실제 문제에서 흔히 접하는 경우를 생각해 보자.</p>
<p>일단 오차항이 서로 독립이지만 분산이 다른 경우이다.</p>
<p><span class="math display">\[ Var(\pmb e) = \text{diag} [\sigma_1^2,\sigma_2^2,\dots, \sigma_n^2 ]  \]</span></p>
<section id="가중-최소제곱법" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="가중-최소제곱법"><span class="header-section-number">4.1.1</span> 가중 최소제곱법</h3>
<p>이러한 경우에 가중 최소제곱법(Weighted Leadt Square Estimator; WLSE)을 사용하면 최소제곱법 추정량의 최적성을 유지할 수 있다.</p>
<p>오차항의 분산 <span class="math inline">\(\sigma_1^2,\sigma_2^2,\dots, \sigma_n^2\)</span>을 안다고 가정하면 각 관측값 <span class="math inline">\(y_i\)</span>를 해당 오차의 표분편차 <span class="math inline">\(\sigma_i\)</span>로 나누면 등분산성을 다시 얻을 수 있다.</p>
<p><span class="math display">\[ Var (y_i) = Var (\pmb x_i^t \pmb \beta + e_i)=Var ( e_i)=\sigma_i^2 \]</span></p>
<p><span class="math display">\[ \Rightarrow Var (y_i/\sigma_i) = Var (\pmb x_i^t \pmb \beta' + e_i/ \sigma_i)=Var ( e_i/\sigma_i) = 1 \]</span></p>
<p>이 떄 새로운 관측치 <span class="math inline">\(y'_i = y_i/\sigma_i\)</span>를 사용하여 최소제곱법을 적용하면</p>
<p><span class="math display">\[ \min_{\pmb \beta'} \sum_{i=1}^n (y'_i - \pmb x_i^t \pmb \beta')^2 = \min_{\pmb \beta}  \sum_{i=1}^n \left [\frac{1}{\sigma_i^2} \right ](y_i - \pmb x_i^t \pmb \beta)^2 \equiv \min_{\pmb \beta}  \sum_{i=1}^n w_i (y_i - \pmb x_i^t \pmb \beta)^2\]</span></p>
<p>여기서 <span class="math inline">\(w_i=1/\sigma^2_i\)</span>이다. 이러한 가중최소제곱법은 각 관측치에 대하여 서로 다른 가중치를 적용하여 최소제곱 추정량을 구하며 위의 경우에는 가중치가 반응값의 분산에 반비례한다. 따라서 분산이 큰 오차항을 가진 반응값의 가중치는 분산이 작은 반응값에 비해 상대적으로 작다. 이러한 가중치와 분산의 관계는 변이가 적은 반응값 근방에서 오차를 더욱 줄이려고 하는 직관적인 생각과 일치한다. 가중치를 적용한 최소제곱 추정량은 다음과 같이 나타낼 수 있다.</p>
<p><span class="math display">\[ \hat  {\pmb \beta}= (\pmb X^t \pmb W \pmb X)^{-1}\pmb X^t \pmb W \pmb y \]</span> 여기서</p>
<p><span class="math display">\[ \pmb W = \text{diag} \left [\frac{1}{\sigma_1^2},\frac{1}{\sigma_2^2},\dots, \frac{1}{\sigma_n^2} \right ] = [Var(\pmb e)]^{-1} =\pmb V^{-1} \]</span></p>
<p>위에서 본 가중최소제곱법을 오차항이 일반적인 공분산 행렬 <span class="math inline">\(\pmb V\)</span>를 가질 때 적용하면 다음과 같이 목적 함수를 나타낼 수 있으며</p>
<p><span class="math display">\[ \min_{\pmb \beta} (\pmb y - \pmb X \pmb \beta)^t \pmb V^{-1} (\pmb y - \pmb X \pmb \beta) \]</span></p>
<p>가중최소제곱추정량은 다음과 같이 나타낼 수 있다.</p>
<p><span id="eq-weightLSE"><span class="math display">\[
\hat  {\pmb \beta}_* = (\pmb X^t \pmb V^{-1} \pmb X)^{-1} \pmb X^t \pmb V^{-1} \pmb y
\tag{4.1}\]</span></span></p>
<p>가중최소제곱추정량은 다음과 같은 성질은 만족한다.</p>
<ul>
<li><p>가중최소제곱추정량은 불편추정량이다: <span class="math inline">\(E(\hat  {\pmb \beta}_*) =\pmb \beta\)</span></p></li>
<li><p>가중최소제곱추정량 <span class="math inline">\(\hat  {\pmb \beta}_*\)</span>는 분산이 가장 작은 불편선형 추정량이다 (Gauss-Markov Theorem)</p></li>
<li><p>가중최소제곱추정량 <span class="math inline">\(\hat  {\pmb \beta}_*\)</span>의 분산:</p></li>
</ul>
<p><span class="math display">\[ Var(\hat  {\pmb \beta}_*) =  (\pmb X^t \pmb V^{-1} \pmb X)^{-1} \]</span></p>
<ul>
<li><p>가중최소제곱추정량 <span class="math inline">\(\hat  {\pmb \beta}_*\)</span>은 <span class="math inline">\(\pmb y\)</span>가 평균이 <span class="math inline">\(\pmb X \pmb \beta\)</span>이고 분산이 <span class="math inline">\(V\)</span>인 정규분포에서 <span class="math inline">\(\pmb \beta\)</span>에 대한 최대우도추정량이다.</p></li>
<li><p>일반최소제곱추정량도 불편추정량이다: <span class="math inline">\(E(\hat  {\pmb \beta}) =\pmb \beta\)</span></p></li>
</ul>
<p>가중최소제곱법에서 유의할 점은 오차항의 공분산 행렬 <span class="math inline">\(\pmb V\)</span>에 대하여 모르는 경우 이를 추정해야 하며 가중최소제곱추정량에 공분산 행렬의 추정치<br>
<span class="math inline">\(\hat {\pmb V}\)</span>을 사용할 경우 위에서 언급한 최적성은 더 이상 성립하지 않는다.</p>
<p><span class="math display">\[ \hat {\pmb \beta}_* = (\pmb X^t \hat {\pmb V}^{-1} \pmb X)^{-1}\pmb X^t \hat {\pmb V}^{-1} \pmb y \]</span></p>
<p>더 나아가 공분산행렬 <span class="math inline">\(\pmb V\)</span>에 대한 추정은 어려운 문제이므로 그 추정 방법과 통계적 성질을 잘 고려하여 사용해야 한다. 정확한 추정을 위해서 또는 자료의 특성을 이용하여 공분산 행렬 <span class="math inline">\(\pmb V\)</span>에 대한 모형을 어느 정ㅇ도 단순화하는 것이 바람직하다. 예를 들어 공분산 행렬 <span class="math inline">\(\pmb V\)</span>를 다음과 같이 나타낼 수 있다면 유용할 것이다.</p>
<p><span class="math display">\[ \pmb V = \sigma^2 \text{diag} [v_1, v_2,\dots, v_n ] \]</span> 여기서 <span class="math inline">\((v_1,v_2,\dots,v_n)\)</span>은 알려진 값이고 <span class="math inline">\(\sigma^2\)</span>는 추정해야하는 모수이다.</p>
<p>오차항의 등분산성에 대한 가정을 검토하기 위한 방법중 가장 유용하고 간단한 방법은 잔차그림을 이용하는 것이다. 잔차 <span class="math inline">\(r_i\)</span>와 적합된 값 <span class="math inline">\(\hat y_i\)</span>에 대한 잔차그림을 그려서 잔차의 퍼진 정도가 적합된 값 <span class="math inline">\(\hat y_i\)</span>에 따라 변하면 등분산성에 대한 가정을 의심해봐야 한다. 실제 자료에서 반응값의 분산이 독립변수에 비례하여 나타나는 경우가 많다. 단순회귀모형을 고려하고</p>
<p><span class="math display">\[ y_i= \beta_0 + \beta_1 x_i + e_i \]</span> 오차항이 서로 독립이며 그 분산이 독립변수에 비례한다고 가정하자.</p>
<p><span class="math display">\[ Var (e_i) = x_i \sigma^2 \]</span> 이러한 경우는 독립변수의 값이 양인 경우이며 독립변수의 값이 커지면 반응값의 분산도 커진다. 이러한 경우 독립변수와 종속변수의 관계, 회귀식, 잔차그림은 다음과 같이 나타난다.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../myimages/hetero.png" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>오차항의 등분산성이 위반된 경우</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="변수변환" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="변수변환"><span class="header-section-number">4.2</span> 변수변환</h2>
<p>변수변환(Variable transformation)은 독립변수와 종속변수를 변환함으로서 회귀식의 적합도를 향상시켜 예측력을 높일 수 있을뿐 아니라 최소제곱법에서의 등분산성 가정에 대한 만족도를 높일 수 있는 유용한 방법이다 (variance stabilization). 이 절에서는 변수변환의 종류와 그 효과를 단순회귀식에서 살펴본다. 중회귀의 경우에는 변수변환의 적용을 복합적으로 고려해야 할 것이다.</p>
<section id="지수모형과-멱함수-로그변환" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="지수모형과-멱함수-로그변환"><span class="header-section-number">4.2.1</span> 지수모형과 멱함수: 로그변환</h3>
<p>회귀식에 대한 모형이 지수함수 모형인 경우, 즉 독립변수와 종속변수가 다음과 같은 경우 <span class="math display">\[ y = \beta_0 \exp (\beta_1 x) \]</span> 종속변수에 대한 로그 변환(log transformation)을 하면 선형관계에 매우 가깝게 된다 ( 아래 그림 참조). <span class="math display">\[ \log(y_i) = \beta,_0 + \beta_1 x_i + e_i \]</span> 여기서 주의할 점은 원래의 지수모형에 오차항의 지수함수가 곱해지는 형태가 되어야 로그 변환후에 등분산성의 가정을 만족하게 된다. 즉 오차항 <span class="math inline">\(e_i\)</span>를 서로 독립이고 평균이 0, 분산이 <span class="math inline">\(\sigma^2\)</span>이라고 하면 다음과 같은 관계가 성립된다. <span class="math display">\[ y_i = \beta_0 \exp (\beta_1 x_i)\exp(e_i) \quad \Rightarrow \quad \log(y_i) = \beta'_0 + \beta_1 x_i + e_i \]</span></p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../myimages/logtrans.png" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>지수모형과 로그변환</figcaption>
</figure>
</div>
</div>
</div>
<p>회귀식에 대한 모형이 멱함수모형인 경우, 즉 독립변수와 종속변수가 다음과 같은 경우 <span class="math display">\[ y = \beta_0  x^\beta_1 \]</span> 독립변수와 종속변수에 대한 로그 변환을 하면 선형관계에 매우 가깝게 된다. <span class="math display">\[ \log(y_i) = \beta,_0 + \beta_1 \log(x_i) + e_i \]</span> 여기서 주의할 점도 원래의 멱함수모형에 오차항이 곱해지는 형태가 되어야 로그 변환후에 등분산성의 가정을 만족하게 된다. 즉 오차항 <span class="math inline">\(e_i\)</span>를 서로 독립이고 평균이 0, 분산이 <span class="math inline">\(\sigma^2\)</span>이라고 하면 다음과 같은 관계가 성립된다. <span class="math display">\[ y_i = \beta_0  x^\beta_1 \exp(e_i) \quad \Rightarrow \quad \log(y_i) = \beta'_0 + \beta_1 \log(x_i) + e_i \]</span></p>
<p>회귀식에 대한 모형이 역지수함수 모형인 경우, 즉 독립변수와 종속변수가 다음과 같은 경우 <span class="math display">\[ y = \beta_0 \exp (\beta_1/ x) \]</span> 종속변수에 대한 로그 변환과 독림변수에 대한 역변환을 하면 선형관계에 매우 가깝게 된다. <span class="math display">\[ \log(y_i) = \beta,_0 + \beta_1 \left ( \frac{1}{x_i} \right ) + e_i \]</span> 여기서 주의할 점은 원래의 역지수모형에 오차항의 지수함수가 곱해지는 형태가 되어야 로그 변환후에 등분산성의 가정을 만족하게 된다.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../myimages/invexp.png" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>역지수모형과 로그/역변환</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="쌍곡선과-역변환" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="쌍곡선과-역변환"><span class="header-section-number">4.2.2</span> 쌍곡선과 역변환</h3>
<p>생물학, 경제학등의 문야에서 독립변수와 종속변수의 관계가 쌍곡선(Hyperbola) 형태인 경우가 많다. 독립변수가 증가함에 따라 종속변수의 값이 수렴하는 경우에 이러한 관계가 매우 유용하다. <span class="math display">\[ y = \frac{x}{\beta_0 + \beta_1 x} \]</span> 이러한 경우에 독립변수와 종속변수에 모두 역변환(Inverse transformation)을 취하면 선형관계에 매우 가깝게 된다 (아래 그림 참조). <span class="math display">\[ \frac{1}{y_i} = \beta_0 + \beta_1 \left ( \frac{1}{x_i} \right ) + e_i \]</span></p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../myimages/hyperbola.png" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>쌍곡선과 역변환</figcaption>
</figure>
</div>
</div>
</div>
<p>위에서 살펴본 회귀모형들에서 변수변환후에 등분산성에 대한 가정을 만족하려면 대부분 변환전의 함수관계식에 오차항의 지수함수가 곱해지는 형태가 되어야 한다 (multiplicative error model). 이렇게 오차항이 함수관계식에 곱해지는 형태가 아니 다른 형태라면, 예를 들어 오차항이 원래의 함수관계식에 더해지는 형태 (additive error model), 등분산성의 가정이 상당히 위배될 수 있음을 주의해야 한다. 예를 들어 회귀식에 대한 모형이 지수함수 모형인 경우 서로 독립이고 평균이 0, 분산이 <span class="math inline">\(\sigma^2\)</span>인 오차항 <span class="math inline">\(e_i\)</span>를 함수 관계식에 더해졌다면 로그변환된 종속 변수와 독립변수는 선형관계를 보이지만 등분산성 가정은 만족하지 못하게된다.</p>
<p><span class="math display">\[ y_i = \beta_0 \exp (\beta_1 x_i) +e_i \quad \Rightarrow \quad \log(y_i) \cong \beta'_0 + \beta_1 x_i + e^*_i \]</span></p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../myimages/adderror.png" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>Additive error model 과 로그변환</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="box-cox-변환" class="level3" data-number="4.2.3">
<h3 data-number="4.2.3" class="anchored" data-anchor-id="box-cox-변환"><span class="header-section-number">4.2.3</span> Box-Cox 변환</h3>
<p>앞 절에서 보았듯이 종속변수에 로그변환 등을 적용하면 여러 가지 유용한 점이 많다. 위에서 살펴본 종속변수에 변환은 여러 가지 비선형모형을 선형모형에 가깝게 만들어 주며 Multiplicative error model과 같이 반응값이 분산이 독립변수의 크기에 영향을 받는 모형을 등분산성을 가진 형태의 모형으로 버꾸어 준다 (Variance stabilization). 이렇게 종속변수에 대한 여러 가지 변환을 하나의 체계적인 형태로 결합한것을 Box-Cox 변환으로 부르며 다음과 같아 정의한다.</p>
<p><span id="eq-boxcox"><span class="math display">\[
y^{(\lambda)} =
\begin{cases}
\log(y) &amp; \text{ if } \lambda=0 \\
\frac{y^\lambda -1}{\lambda} &amp; \text{ if } \lambda \ne 0
\end{cases}
\tag{4.2}\]</span></span></p>
<p>Box-Cox 변환은 로그변환과 멱변환을 모두 포함하고 있다. 또한 Box-Cox 변환된 <span class="math inline">\(y^{(\lambda)}\)</span>가 정규분포를 따른다는 가정 하에 자료가 주어졌을때 <span class="math inline">\(\lambda\)</span>에 대한 최대우도추정량을 구할 수 있다.</p>
</section>
</section>
<section id="다중공선성" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="다중공선성"><span class="header-section-number">4.3</span> 다중공선성</h2>
<p>회귀분석에서 독립변수들간의 강한 선형 관계의 경향이 있을 때 이를 다중공선성(multicollinearity)라고 한다. 즉, <span class="math inline">\(p\)</span>개의 독립변수 <span class="math inline">\(x_1,x_2,\dots,x_p\)</span>의 관계가 다음과 같은 선형관계에 가깝다면 다중공선성이 존재한다고 한다.</p>
<p><span class="math display">\[ c_1 x_1 + c_2 x_2 + \dots + c_p x_p \cong 0 \]</span></p>
<p>다중공선성에 의해 발생하는 여러 가지 문제점들을 기술적으로 독립변수들의 강한 선형관계때문에 행렬 <span class="math inline">\(X^tX\)</span>가 ill-conditioned 행렬이 되어 그 역행렬이 불안정하게 구해지는 결과 때문에 생기게 된다. 여기서 회귀계수의 공분산 행렬은 다음과 같이 주어짐에 유의하자.</p>
<p><span class="math display">\[ Var(\pmb b) = \sigma^2 (X^t X)^{-1} \]</span></p>
<p>예를 들어서 두 개의 독립변수가 있는 회귀 모형을 생각해 보자.</p>
<p><span class="math display">\[ y = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + e \]</span></p>
<p><a href="#fig-multicol" class="quarto-xref">그림&nbsp;<span>4.1</span></a> 에서 (a)의 경우는 두 개의 독립변수 <span class="math inline">\(x_1\)</span>과 <span class="math inline">\(x_2\)</span>의 관계가 독립적이어서 (linearly independent) 적합된 회귀식이(그림에서 2차원 평면) 안정적이다. 반면에 <a href="#fig-multicol" class="quarto-xref">그림&nbsp;<span>4.1</span></a> 에서 (b)의 경우는 두 개의 독립변수 <span class="math inline">\(x_1\)</span>과 <span class="math inline">\(x_2\)</span>가 완벽한 선형관계가 있기 떄문에 (linearly dependent)</p>
<p><span class="math display">\[ c_1 x_1 + c_2 x_2 = 0 \]</span> 적합된 회귀식이 여러가지 존재한다. 이러한 경우는 매우 드물지만 <a href="#fig-multicol" class="quarto-xref">그림&nbsp;<span>4.1</span></a> 에서 (c)의 경우는 두 개의 독립변수 <span class="math inline">\(x_1\)</span>과 <span class="math inline">\(x_2\)</span>가 선형관계에 매우 가깝기 때문에 적합된 회귀식이 불안정하다.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-multicol" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-multicol-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="../myimages/multicol.jpg" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-multicol-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;4.1: 회귀분석에서의 다중공선성의 정도(Fox 2008, p310)
</figcaption>
</figure>
</div>
</div>
</div>
<p>회귀분석에서 다중공선성의 정도를 측정할 수 있는 통계량은 다음과 같은 것들이 있다.</p>
<section id="독립변수간의-상관계수" class="level3" data-number="4.3.1">
<h3 data-number="4.3.1" class="anchored" data-anchor-id="독립변수간의-상관계수"><span class="header-section-number">4.3.1</span> 독립변수간의 상관계수</h3>
<p>독립변수간의 상관계수를 보아 강한 상관관계를 가지는 변수들이 있다면 다중공선성의 가능성이 크다.</p>
</section>
<section id="pmb-xt-pmb-x-의-고유값eigenvalues" class="level3" data-number="4.3.2">
<h3 data-number="4.3.2" class="anchored" data-anchor-id="pmb-xt-pmb-x-의-고유값eigenvalues"><span class="header-section-number">4.3.2</span> <span class="math inline">\(\pmb X^t \pmb X\)</span> 의 고유값(Eigenvalues)</h3>
<p>행렬 <span class="math inline">\(\pmb X^t \pmb X\)</span>의 고유값를 구하여 큰 순서대로 나열했을 때 가장 작은 값이 0에 매우 가까우면 다중공선성의 가능성이 크다. 만약에 독립변수들간의 선형 관계가 있다면 행렬 <span class="math inline">\(\pmb X^t \pmb X\)</span>은 최대 계수(full rank) 행렬이 아니므로 하나 이상의 고유값이 0이 되게 된다.</p>
<p>이제 <span class="math inline">\(\lambda_1 \ge \lambda_2 \ge \dots \ge \lambda_p\)</span>를 <span class="math inline">\(\pmb X^t \pmb X\)</span>의 고유값라고 하자. 이런 가정 하에서 <span class="math inline">\(1/\lambda_i\)</span>는 <span class="math inline">\((\pmb X^t \pmb X)^{-1}\)</span>의 고유값이다. <span class="math inline">\(\pmb X^t \pmb X\)</span>의 고유값에 대한 고유벡터를 <span class="math inline">\(\pmb p_1, \pmb p_2,\dots,\pmb p_p\)</span>라고 하고 행렬 <span class="math inline">\(\pmb P=[\pmb p_1, \pmb p_2,\dots,\pmb p_p]\)</span>로 정의하자. 이때 다음과 같이 스펙트렇 분해를 이용하여 <span class="math inline">\(\pmb X^t \pmb X\)</span>를 나타낼 수 있다.</p>
<p><span class="math display">\[ \pmb P^t (\pmb X^t \pmb X) \pmb P = \pmb \Lambda = \text{diag}(\lambda_1 , \lambda_2 , \dots , \lambda_p) \]</span> 또한</p>
<p><span class="math display">\[ (\pmb X^t \pmb X)^{-1} =  \pmb P \pmb \Lambda^{-1}\pmb P^t  \]</span> 따라서 가장 작은 고유값 <span class="math inline">\(\lambda_p\)</span>가 매우 0에 가까우면 <span class="math inline">\((\pmb X^t \pmb X) \pmb p_p =\lambda_p \pmb p_p \approx 0\)</span>이 성립하고 이는 <span class="math inline">\(\pmb X \pmb p_p \approx 0\)</span>을 의미하여 독립변수간에 선형관계가 있다는 것을 암시한다.</p>
<p>일반적으로 최소제곱추정량의 공분산은 다음과 같아 나타내어지고</p>
<p><span class="math display">\[ Var(\hat {\pmb \beta}) = \sigma^2 (\pmb X^t \pmb X)^{-1} = \sigma^2 \pmb P \pmb \Lambda^{-1}\pmb P^t  =
\sigma^2  \sum_{i=1}^p \frac{1}{\lambda_i} \pmb p_i \pmb p^t_i \]</span></p>
<p>최소제곱추정량의 분산의 합(total variance)은 다음과 같다.</p>
<p><span class="math display">\[ \sum_{i=1}^p Var(\hat \beta_i) = tr[\sigma^2 (\pmb X^t \pmb X)^{-1}]= \sigma^2 tr[ (\pmb X^t \pmb X)^{-1}]=
\sigma^2 \sum_{i=1}^p \frac{1}{\lambda_i} \]</span></p>
<p>따라서 고유값의 값이 0에 가까와 지면 추정량의 분산의 합은 매우 크게 된다.</p>
</section>
<section id="조건지수-condition-number" class="level3" data-number="4.3.3">
<h3 data-number="4.3.3" class="anchored" data-anchor-id="조건지수-condition-number"><span class="header-section-number">4.3.3</span> 조건지수 (condition number)</h3>
<p>다중공선성의 판별을 위하여 행렬 <span class="math inline">\(\pmb X^t \pmb X\)</span>의 고유값이 중요한 측도라고 했다. 고유값을 상대적으로 비교하면 다중공선성을 더 명확하게 알 수 있다. 조건지수는 가장 튼 고유값과 다른 고유값의 비율의 제곱근으로 나타내어진다.</p>
<p><span class="math display">\[ \kappa_i = \sqrt{\frac {\lambda_1}{\lambda_i}}, \quad i=2,3,\cdots,p \]</span></p>
<p>중요한 역활을 하는 조건지수는 가장 작은 고유값에 의한 것이다.</p>
<p><span class="math display">\[ \kappa_p =\kappa(\pmb X) = \sqrt{\frac {\lambda_1}{\lambda_p}} \]</span></p>
<p><span class="math inline">\(\kappa(\pmb X)\)</span>의 값이 크면 클수록 다중공선성의 가능성이 높다. 일반적으로 <span class="math inline">\(\kappa(\pmb X)\)</span> 가 30 이상이면 다중공선성의 가능성이 크다고 본다.</p>
</section>
<section id="분산팽창계수-variance-inflation-factor-vif" class="level3" data-number="4.3.4">
<h3 data-number="4.3.4" class="anchored" data-anchor-id="분산팽창계수-variance-inflation-factor-vif"><span class="header-section-number">4.3.4</span> 분산팽창계수 (Variance Inflation Factor ;VIF)</h3>
<p>하나의 독립변수 <span class="math inline">\(x_i\)</span>를 나머지 다른 <span class="math inline">\(p-1\)</span>개의 독립변수 <span class="math inline">\(x_1,\dots, x_{i-1}, x_{i+1},\dots, x_p\)</span>를 이용하여 회귀식을 적합시킬 수 있다. 이때 다중공선성이 존재한다면 적합된 회귀식의 결정계수 <span class="math inline">\(R^2_i\)</span>는 1에 매우 가까울 것이다</p>
<p><span class="math display">\[ x_i = \beta_0 + \beta_1 x_1 + \dots + \beta_{i-1} x_{i-1} +\beta_{i+1} x_{i+1} + \dots + \beta_p x_p +e \]</span></p>
<p>이때 독립변수 <span class="math inline">\(x_i\)</span>에 대한 VIF는 다음과 같이 정의되며 그 값이 5 또는 10보다 크면 다중공선성의 가능성이 크다.</p>
<p><span class="math display">\[ VIF_i = \frac{1}{1-R_i^2} \]</span></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../qmd/inference2.html" class="pagination-link" aria-label="모형의 비교">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">모형의 비교</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../qmd/residual.html" class="pagination-link" aria-label="관측값에 대한 진단">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">관측값에 대한 진단</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>